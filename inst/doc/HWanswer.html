<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Hanlu Zhang" />

<meta name="date" content="2023-12-04" />

<title>StatComp Homework</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">StatComp Homework</h1>
<h4 class="author">Hanlu Zhang</h4>
<h4 class="date">2023-12-04</h4>



<div id="hw0" class="section level1">
<h1>HW0</h1>
<div id="作业内容与思路" class="section level2">
<h2>作业内容与思路</h2>
<p>作业内容：使用<strong>Knit</strong>生成至少3个例子，每个例子应当图（表）文并茂。最好还有数学公式。</p>
<p>思路：选择四个统计学方法为本次作业的例子，由易到难分别是相关系数、两样本t检验、回归分析、树模型。这些例子既能以公式的形式解释数学原理，也能通过精致的图表来展示结果。使用的数据集为<strong>R</strong>自带的<strong>mpg</strong>数据集。</p>
<p>数据介绍：<strong>mpg</strong>数据集共有234行11列，每一个变量的含义及数据类型如表1所示。在本次作业中，我们只选择五个数值型变量进行分析。</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">data</span>(mpg)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a>mydata <span class="ot">=</span> mpg[,<span class="fu">c</span>(<span class="st">&#39;displ&#39;</span>,<span class="st">&#39;year&#39;</span>,<span class="st">&#39;cyl&#39;</span>,<span class="st">&#39;cty&#39;</span>,<span class="st">&#39;hwy&#39;</span>)]</span>
<span id="cb1-3"><a href="#cb1-3" tabindex="-1"></a><span class="fu">summary</span>(mydata)</span></code></pre></div>
<pre><code>##      displ            year           cyl             cty             hwy       
##  Min.   :1.600   Min.   :1999   Min.   :4.000   Min.   : 9.00   Min.   :12.00  
##  1st Qu.:2.400   1st Qu.:1999   1st Qu.:4.000   1st Qu.:14.00   1st Qu.:18.00  
##  Median :3.300   Median :2004   Median :6.000   Median :17.00   Median :24.00  
##  Mean   :3.472   Mean   :2004   Mean   :5.889   Mean   :16.86   Mean   :23.44  
##  3rd Qu.:4.600   3rd Qu.:2008   3rd Qu.:8.000   3rd Qu.:19.00   3rd Qu.:27.00  
##  Max.   :7.000   Max.   :2008   Max.   :8.000   Max.   :35.00   Max.   :44.00</code></pre>
</div>
<div id="汽车变量的相关性分析" class="section level2">
<h2>汽车变量的相关性分析</h2>
<p>我们计算各指标的Pearson相关系数。指标<span class="math inline">\(X\)</span>和指标<span class="math inline">\(Y\)</span>的Pearson相关系数的计算公式如下： <span class="math display">\[\rho=\dfrac{Cov(X,Y)}{\sqrt{Var(X)Var(Y)}}.\]</span></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a><span class="fu">cor</span>(mydata, <span class="at">method =</span> <span class="fu">c</span>(<span class="st">&quot;pearson&quot;</span>))</span></code></pre></div>
<pre><code>##            displ         year        cyl         cty          hwy
## displ  1.0000000  0.147842816  0.9302271 -0.79852397 -0.766020021
## year   0.1478428  1.000000000  0.1222453 -0.03723229  0.002157643
## cyl    0.9302271  0.122245347  1.0000000 -0.80577141 -0.761912354
## cty   -0.7985240 -0.037232291 -0.8057714  1.00000000  0.955915914
## hwy   -0.7660200  0.002157643 -0.7619124  0.95591591  1.000000000</code></pre>
<p>cty和hwy的相关系数最高。
说明城市燃油率和高速燃油率之间高度线性相关。</p>
</div>
<div id="汽车变量的假设检验" class="section level2">
<h2>汽车变量的假设检验</h2>
<p><strong>mpg</strong>数据集包含了1999年的数据与2008年的数据。我们以年份为分组指标，用两样本t检验的方法比较两年的发动机排量是否有显著差异。记两组样本分别为<span class="math inline">\(x_1,x_2,\cdots,x_m\)</span>，来自正态总体<span class="math inline">\(N(\mu_1,\sigma_1^2)\)</span>，<span class="math inline">\(y_1,y_2,\cdots,y_n\)</span>，来自正态总体<span class="math inline">\(N(\mu_2,\sigma_2^2)\)</span>。t统计量的计算公式如下：
<span class="math display">\[t = \dfrac{\bar x-\bar
y}{s_w\sqrt{\dfrac{1}{m}+\dfrac{1}{n}}}.\]</span></p>
<p>其中，<span class="math inline">\(s_w=(\dfrac{1}{m+n-2}(\sum\limits_{i=1}^m(x_i-\bar
x)^2+\sum\limits_{i=1}^n(y_i-\bar y)^2))^{\frac{1}{2}}\)</span>.</p>
<p>t检验的P值&lt;0.05，认为1999年的发动机排量与2008年的有显著差异。由计算的均值可知，2008年的发动机排量更高。</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>mydata<span class="sc">$</span>year <span class="ot">&lt;-</span> <span class="fu">as.factor</span>(mydata<span class="sc">$</span>year)</span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a><span class="fu">t.test</span>(displ<span class="sc">~</span>year, mydata, <span class="at">var.equal=</span>T)</span></code></pre></div>
<pre><code>## 
##  Two Sample t-test
## 
## data:  displ by year
## t = -2.2769, df = 232, p-value = 0.0237
## alternative hypothesis: true difference in means between group 1999 and group 2008 is not equal to 0
## 95 percent confidence interval:
##  -0.71105335 -0.05133981
## sample estimates:
## mean in group 1999 mean in group 2008 
##           3.281197           3.662393</code></pre>
</div>
<div id="汽车变量的线性回归分析" class="section level2">
<h2>汽车变量的线性回归分析</h2>
<p>我们用多元线性模型，探究发动机排量和气缸数量对高速燃油率的影响。以displ和cyl为自变量，hwy为响应变量，拟合如下线性模型：
<span class="math display">\[hwy =
\beta_0+\beta_1·displ+\beta_2·cyl.\]</span></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a>lm_model <span class="ot">=</span> <span class="fu">lm</span>(hwy<span class="sc">~</span>displ<span class="sc">+</span>cyl, mydata)</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a><span class="fu">par</span>(<span class="at">mfrow=</span><span class="fu">c</span>(<span class="dv">2</span>,<span class="dv">2</span>), <span class="at">mar =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>))</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a><span class="fu">plot</span>(lm_model)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>拟合的线性模型结果为<span class="math inline">\(hwy =
38.2162-1.9599·displ-1.3537·cyl\)</span>。模型调整后的<span class="math inline">\(R^2\)</span>为0.6014414，从残差图可以看出，模型达到了较好的拟合效果。</p>
</div>
<div id="汽车变量的决策树模型" class="section level2">
<h2>汽车变量的决策树模型</h2>
<p>我们选用决策树模型探究displ、year、cyl、cty四个变量中，哪个变量对hwy的影响最大。决策树的算法是以特征（变量）的信息增益为基础的。给定数据集<span class="math inline">\(D\)</span>和特征<span class="math inline">\(A\)</span>，信息增益<span class="math inline">\(g(D,A)\)</span>的计算公式如下： <span class="math display">\[g(D,A) = H(D) - H(D|A).\]</span></p>
<p>其中，<span class="math inline">\(H(D)\)</span>是数据集<span class="math inline">\(D\)</span>的经验熵，<span class="math inline">\(H(D)=-\sum\limits_{k=1}^K\dfrac{|C_k|}{|D|}\log_2\dfrac{|C_k|}{|D|}\)</span>。<span class="math inline">\(H(D|A)\)</span>是特征<span class="math inline">\(A\)</span>对数据集<span class="math inline">\(D\)</span>的经验条件熵，<span class="math inline">\(H(D|A)=\sum\limits_{i=1}^n\dfrac{|D_i|}{|D|}H(D_i)\)</span>。</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a>tree_model <span class="ot">=</span> <span class="fu">rpart</span>(hwy<span class="sc">~</span>., <span class="at">data =</span> mydata)</span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a><span class="fu">rpart.plot</span>(tree_model)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>根据信息增益结果，绘制树状图。由图像可以看出，模型中最重要的指标是城市燃油率（cty），它对高速燃油率影响最大。</p>
</div>
</div>
<div id="hw1" class="section level1">
<h1>HW1</h1>
<div id="第一题" class="section level2">
<h2>第一题</h2>
<p><em>问题描述：</em>标准拉普拉斯分布的密度函数是<span class="math inline">\(f(x)=\frac{1}{2}e^{-|x|},~x\in
R\)</span>。用inverse transform
method生成1000个服从该分布的随机样本，再用一种方法来比较生成的样本和目标分布。</p>
<p><em>思路：</em> （1）inverse transform
method生成随机样本：计算累计密度函数，求逆分布函数，生成<span class="math inline">\(U(0,1)\)</span>分布随机数，将随机数代入逆分布函数；
（2）生成目标分布：采用<strong>R</strong>中的<code>rlaplace()</code>函数；
（3）用直方图来比较生成样本和目标分布。</p>
<p>首先计算标准拉普拉斯分布的累计密度函数，由累计密度函数的定义： <span class="math display">\[F(x) = \int _{-\infty}^x f(u)du = \int
_{-\infty}^x \dfrac{1}{2}e^{-|u|} du, \]</span> <span class="math display">\[when~x&gt;0,~F(x) = \int _{-\infty}^0
\dfrac{1}{2}e^{u} du + \int _{0}^x \dfrac{1}{2}e^{-u} du =
1-\dfrac{1}{2}e^{-x}, \]</span> <span class="math display">\[when~x\leq
0,~F(x) = \int _{-\infty}^x \dfrac{1}{2}e^{u} du = \dfrac{1}{2}e^{x}.
\]</span> 因此，<span class="math inline">\(F(x) =
\dfrac{1}{2}[1+sign(x)(1-e^{-|x|})]\)</span>，其中，<span class="math inline">\(sign(x)\)</span>是符号函数，<span class="math inline">\(x&gt;0\)</span>时，<span class="math inline">\(sign(x)=1\)</span>；<span class="math inline">\(x=0\)</span>时，<span class="math inline">\(sign(x)=0\)</span>；<span class="math inline">\(x&lt;0\)</span>时，<span class="math inline">\(sign(x)=-1\)</span>；。</p>
<p>令<span class="math inline">\(u=F(x)\)</span>，解得标准拉普拉斯分布的逆分布函数为：
<span class="math display">\[F^{-1}(u)=sign(\dfrac{1}{2}-u)\ln
(1-2|u-\dfrac{1}{2}|).\]</span> 本题的<strong>R</strong>代码如下：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>n <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>u <span class="ot">=</span> <span class="fu">runif</span>(n)</span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>generate_sample <span class="ot">=</span> <span class="fu">sign</span>(<span class="fl">0.5</span><span class="sc">-</span>u)<span class="sc">*</span><span class="fu">log</span>(<span class="dv">1-2</span><span class="sc">*</span><span class="fu">abs</span>(u<span class="fl">-0.5</span>))</span></code></pre></div>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a><span class="co"># 绘制图像</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a><span class="fu">hist</span>(generate_sample, <span class="at">breaks=</span><span class="dv">30</span>, <span class="at">xlim=</span><span class="fu">c</span>(<span class="sc">-</span><span class="dv">10</span>,<span class="dv">10</span>), <span class="at">prob=</span><span class="cn">TRUE</span>, </span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>     <span class="at">col=</span><span class="fu">rgb</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="fl">0.5</span>), <span class="at">xlab=</span><span class="st">&quot;sample&quot;</span>, <span class="at">ylab=</span><span class="st">&quot;Density&quot;</span>,</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a>     <span class="at">main =</span> <span class="st">&quot;Histogram of standard laplace&quot;</span>)</span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a>y <span class="ot">=</span> <span class="fu">seq</span>(<span class="sc">-</span><span class="dv">10</span>, <span class="dv">10</span>, <span class="fl">0.1</span>)</span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="fu">lines</span>(y, <span class="fl">0.5</span><span class="sc">*</span><span class="fu">exp</span>(<span class="sc">-</span><span class="fu">abs</span>(y)))</span></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAwFBMVEUAAAAAADoAAGYAOjoAOmYAOpAAZpAAZrY6AAA6ADo6AGY6OgA6Ojo6OmY6OpA6ZpA6ZrY6kLY6kNtmAABmADpmOgBmOjpmkJBmkLZmkNtmtrZmtttmtv+QOgCQZgCQZjqQkGaQkLaQtpCQttuQtv+Q29uQ2/+2ZgC2Zjq2ZpC2kDq2kGa225C227a229u22/+2/9u2///bkDrbkGbbtmbbtpDb27bb29vb////f3//tmb/25D/27b//7b//9v///+HI7yAAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAKzElEQVR4nO2dC3vbthmF4cSelXlZOqnp1sXepd3M7KqWbTpZtqz//6+GC0mApMgDShAIUufsmeoQ0PcBr3AnCIo91SsxdgJSFwEBERAQAQEREBABAREQEAEBERAQAQEREBABAREQEAEBERAQAQEREBABAREQEAEBERAQAQEREBABAREQEAEBERAQAQEREBABAREQEAEBdQJ6fRA3G/Pf2+ofTvA/fgycktfPCyG+al/GjjLxpi9OFdzOheOmK+xIQC8fe9N0jLZCatm86uMoAUBD03SMcnH1eJyjBAAV//jpToirD2vlU0q5/fKNEG//oC2/fhbi+lGnRub1u4/izXr/5aOM917me7cSt1/uxNWn/U8LGcu6qQxokyWilqPKkLL9d+3J+JTWvjcEalGMezfYZslGlCH/kf6v1wfC9vufZSLefhoCKBeiSG+Z7uKKiiijqBze2cs3m60JltmWgIzuSrRG1oALqOXIGirD9N/Gp4nZinKzcYNtlpyImbXVCqsCewCVKgCpUrDZ/6wbCvOrPC8KbkvdhNxuXrOS2816/z/5rV9tVKSlBrRU3xWfivhargFbxVqOHEMqsvzFXZ+flc9GFOXeDbaA3IgqtWvl6LYdJr/8u83Laggg+cXr/xahBlBReDPzW6u/Zd4MoPsi4i//ulMG5HVJwnyaBDhm9mW9fKywNRxZQ4VtGeV2X/PZitIKtu1MGTEzETMDuBmmvpV/GADIXDEtTvnDaqMqa+Xftby+/rk0oArFvvi0gFwDDqCWI8dQEU1bKvsPk5hmlHqwdedELEJs+m1YBWxIG/Ty0dTQvxWmTX51abwv/3YBqYxe//WXVScg14DbizUdOYZcQK7PdpRasM2SG7EIUe6bYVXnPWwc9PKXu7JJ9ShBhsSuG1BHCWo5cgw1SlDlsx2lFmzduRGbJcgJO6oEmet/si1OdxukU7gtm4tlB6CONqjlyDHkAnJ9tqN0tEFuxGYbVA9T39q+HwBIt+uq+OuOR6WhuxcrS9DN5uWhuw3q6MVajhxDNUCOz3aUepLcElRFbPZibpj88le6zg0oQZ/tKGEr+sdBVRvU20i74yC3BDUd/WAN1QBVYxXTBjUaaTfYZsmN6IS3wnzGQa0qpsaW4v16Xwyb18VA+FvzBXnpt+tWL3b9fS4vdQFyDLhVrOnIGqoDev3nQg52q16sFqUebLPkRJQhP8h/fVgfCCtG0t+GXu7Iuqc76clnohcMUKbXKswAbiqKCqiYxhyckqeqqID2L98siin4ZBQX0ExFQEAEBERAQAQEREBABAREQEAEBERAQAQEREBABAREQEAEBERAQAQEREBABAREQEAEBERAQAQEREBABAREQEAEBDQBQN17mKJ4H9O5nwgIiICACKhPvfsooyRgTOceEk9P0wP0vLjHkQJpUoCqh76E8Ni7FkaTArTfmg3OLEGd2q3ULui4gOT/onk7lICB8TP96ERkQGMSGuw7F0sC6tXz4i0B9er1QRBQMpoqoDzeOGiagJpWKgUx51qeB6BzmSMgbHBagMqHOjtboPCA1FxjzK5kkOu8fNh02z7o5whzPpoUoNcH+7Ryx5Oplw1ot6oGiNuOSnbZgFiCkPJyjsE2qEPlmmLns/GXDii2OQLCBgkIGNSL0iPeG5sEoDEX7ivH5YFWgcyFUjqAzFk+Hb33MebCKCVA+wCM5g7IIDphtXDmgNQRN/dyRnH8GUlzBqRGyYZM10x0kLlAknCe9P9DG/ZOQPnHbhXiaKQ5A/ra8Dmh+OwvAtBpN3RmCyizN26O6ebPedsnDUC2BAUyF0rpAErSHAFBe4kA2q2W1QbEpBrpVAClao6AoL2EAMlqpt8ncNJZtXMGlKkDp2/32UnLZjMGpG6bbuVcPqmphkiom1eAMnVadaKAxiLkVLFbtU18t0qpiiUFSA6E1NsTTlu5nzMgH+WieCtMV0W8cEC5fs+TKmMjABrp5qF1CrfXFdtf9JJ1HEDCmayO9VCL00jD7qvcQCVHTBcISA2kgaoNVNntRQLCD2CUWOzrcjrNhZCu8ckA8urgyy1mrw9xAJVwUgCk5xkBzQVQHdBIPb27uyO1BbO0AA1TlEZ6yoCaVs5y2yc1QPodltlpO4TCAnpKCtD26jFXs/l09gc1AI3ezS/1/vne9aC4T/ukBUgNFBWgvhXFyE/7pAWoLEFZ96p95Gc1RFqAijYo7xkuRn7aJzVAZqjYt4vqwkuQh+I+7TNBQFGf9hGJNdIm76e+AzRYHupLHSOuS5c+s2Ix/sS99uEA6QWOdABty8b5xKNv5grIWS1L5N78QUBjPDdWbaAqLyRy6/lwCRqhDJWA4BBwiLkAOghojEqWLCDRhGOWPELZ90+I/iSg7oToTwLqToj+DHbGZsA2KClA6ZkjIGCHgICdLkDRCSV622dugEKbO7DUUVax2IQICCYlRXMEBM10tkGxJ6wpAjq4mlgAir7ymiSgw3AqQFFLUWqAekpPBShqKUoOkCohqARdNqBDC2UEZA14AHqKuZ9zkoBizjiGeTr//qCOhbKJAIqwP6gHTvq9WITdHX09WA1QNEJDHJ1/f1DvGKgOKNZgMaUSBAaJNUDRClFC+4MQnAagSIRS2B9k6gssPS1AUd5+mMI4qCwOg0uQo7DZcBOXgLkqlwMBmVG1OG+3f6Tl0x5msb+5L5huQE5JOi4rKK1hrNQTKZLWGIBmLAICCjxZnZ8CT1bnp8BTjcJo0jofIO9tVr5GPeONEu2Y6P4lKKzzyQDymKwOMzo7QHiyOszo/AAFNkpAYeIRUIrRjowe1igBhYk3P0BzEgEBERAQAQEREBABAREQEAEBERAQAQEREBABAREQUHhAz7/WNzy2/adZKZkFXHBWiIcdX1MDkmYVHNBupe8IqeNktiAZz+9wMn3seJoakjSr0IC25r60uUMETpLxOMPAy46fqUFJswoMaCuWOq3mGCJwkkyOE+llx8/UoKRZhW+DTCp0kQe/a/YbgV6p6GXHz9SgpFmdCZCp4/01Xb0IRmatN1s+djxNDUmaoxEBOdG7Q4fkBpaKhAD5l+P+Q9MG1Qd4/tqoVax6E7tPS+i8tr2/gx7UosK+PqFG2qcvNSnt/yk9+2QfU0OS5uhMgLxGYzqRoGX1HNX5mBqSNKtzAVK1CCZCvUAZHdvoY8fT1JCkVeJkFYiAgAgIiICACAiIgIAICIiAgAgIiICACAiIgIAICIiAgAgIiICACAiIgIAICIiAgAgIiICACAiIgIAICIiAgAgIaHKAnBNWooiAgAgIKCFAz4tiC0uxleV58ceVEEt1+X7//O67hd6VpgHlPntawygdQHqX2FayUJuh8qtHeUF+5Grzd/7mR4npXocqQCY0DqF0AJUb6HZfPxpaGkHxcW945DcbCci89PS0dw16Kx1AxZMUWltdqxb3++qj2IV49SgBmf1zJ75T2FfpADJnEJoG5s2/F01A74rdzQpQcVrbpQFSyq4eKy7dgPx3GJ6uxACp7Ovt8O0qpjfvFm1QxJ4+HUC6XGxNCdqtZC/eAKQ27zq9mCpsMZKVDiDVMuvtuXqXrlvXDKDf6/GQHQdFOi41IUC9itRntUVAQAQENBVAo4mAgAgIiICACAiIgIAICIiAgAgIiICACAiIgIAICIiAgAgIiICACAiIgIAICIiAgAgI6P/0zj2d4V7UzwAAAABJRU5ErkJggg==" /><!-- --></p>
<p>图像上红色部分是用逆变换法生成的样本的直方图，黑色曲线是目标分布的概率密度曲线。通过比较可以看出，逆变换法生成的样本分布很接近目标分布。然而，通过<code>hist</code>函数的<code>main</code>参数的<code>expression</code>生成直方图标题中的公式时，<code>e^{-|x|}</code>语法报错，尚未得到解决，因此直方图为文字标题。</p>
<p><em>参考资料：</em> （1）<a href="https://search.r-project.org/CRAN/refmans/VGAM/html/laplaceUC.html" class="uri">https://search.r-project.org/CRAN/refmans/VGAM/html/laplaceUC.html</a></p>
</div>
<div id="第二题" class="section level2">
<h2>第二题</h2>
<p><em>问题描述：</em>写一个函数，用acceptance-rejection
method来生成服从分布<span class="math inline">\(Beta(a,b)\)</span>的<span class="math inline">\(n\)</span>个随机样本。生成服从分布<span class="math inline">\(Beta(3,2)\)</span>的1000个随机样本。画出生成的样本的直方图，并在上面叠加理论<span class="math inline">\(Beta(3,2)\)</span>的密度。</p>
<p><em>思路：</em> （1）先找到<span class="math inline">\(Beta(a,b)\)</span>的概率密度函数的包络函数<span class="math inline">\(g(t)\)</span>，推导随机变量<span class="math inline">\(x\)</span>被接受的条件；
（2）多次循环，得到指定size的<span class="math inline">\(Beta(a,b)\)</span>样本。</p>
<p><span class="math inline">\(Beta(a,b)\)</span>的概率密度函数为：
<span class="math display">\[f(x) =
\dfrac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}x^{a-1}(1-x)^{b-1},~0&lt;x&lt;1.\]</span>
其中，<span class="math inline">\(\Gamma(x+1)=x!\)</span>。</p>
<p>令<span class="math inline">\(g(x)\)</span>为均匀分布<span class="math inline">\(U(0,1)\)</span>的概率密度函数，则<span class="math inline">\(\forall x\in(0,1),~f(x)/g(x)\leq
\dfrac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}\)</span>，因此<span class="math inline">\(f(x)/g(x)\)</span>的上界<span class="math inline">\(c=\dfrac{\Gamma(a)\Gamma(b)}{\Gamma(a+b)}\)</span>。那么，来自<span class="math inline">\(g(x)\)</span>的随机变量<span class="math inline">\(x\)</span>被接受的条件是： <span class="math display">\[\dfrac{f(x)}{cg(x)}=\dfrac{\dfrac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}x^{a-1}(1-x)^{b-1}}{\dfrac{\Gamma(a+b)}{\Gamma(a)\Gamma(b)}·1}=x^{a-1}(1-x)^{b-1}&gt;u,\]</span>
其中，<span class="math inline">\(u\)</span>为均匀分布<span class="math inline">\(U(0,1)\)</span>的随机变量。</p>
<p>用acceptance-rejection method来生成服从分布<span class="math inline">\(Beta(a,b)\)</span>的<span class="math inline">\(n\)</span>个随机样本的<strong>R</strong>函数如下，其中<span class="math inline">\(a,b\)</span>分别为<span class="math inline">\(Beta(a,b)\)</span>的参数，<code>n</code>为样本size：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>generate_beta <span class="ot">=</span> <span class="cf">function</span>(a, b, n){</span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>  k <span class="ot">=</span> <span class="dv">0</span> <span class="co"># counter for accept</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>  j <span class="ot">=</span> <span class="dv">0</span> <span class="co"># iterations</span></span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>  beta_sample <span class="ot">=</span> <span class="fu">numeric</span>(n)</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>  <span class="cf">while</span> (k <span class="sc">&lt;</span> n) {</span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a>    u <span class="ot">=</span> <span class="fu">runif</span>(<span class="dv">1</span>) <span class="co"># upper bound</span></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a>    j <span class="ot">=</span> j <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a>    x <span class="ot">=</span> <span class="fu">runif</span>(<span class="dv">1</span>) <span class="co"># r.v. from g</span></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a>    <span class="cf">if</span> (x<span class="sc">^</span>(a<span class="dv">-1</span>)<span class="sc">*</span>(<span class="dv">1</span><span class="sc">-</span>x)<span class="sc">^</span>(b<span class="dv">-1</span>)<span class="sc">&gt;</span>u){</span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a>      <span class="co"># accept x</span></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a>      k <span class="ot">=</span> k <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a>      beta_sample[k] <span class="ot">=</span> x</span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a>    }</span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a>  }</span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a>  <span class="fu">return</span>(beta_sample)</span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a>}</span></code></pre></div>
<p>用自定义函数<code>generate_beta</code>生成服从分布<span class="math inline">\(Beta(3,2)\)</span>的1000个随机样本，画出样本直方图，并在图上叠加理论<span class="math inline">\(Beta(3,2)\)</span>的密度曲线。</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a><span class="co"># 生成</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>a <span class="ot">=</span> <span class="dv">3</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>b <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>Beta_Sample <span class="ot">=</span> <span class="fu">generate_beta</span>(a,b,<span class="dv">1000</span>)</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a><span class="co"># 画图</span></span>
<span id="cb12-7"><a href="#cb12-7" tabindex="-1"></a><span class="fu">hist</span>(Beta_Sample, <span class="at">breaks=</span><span class="dv">30</span>, <span class="at">xlim=</span><span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>), <span class="at">prob=</span><span class="cn">TRUE</span>, <span class="at">col=</span><span class="fu">rgb</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="fl">0.5</span>), <span class="at">xlab=</span><span class="st">&quot;sample&quot;</span>, </span>
<span id="cb12-8"><a href="#cb12-8" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">&quot;Density&quot;</span>, <span class="at">main =</span> <span class="st">&quot;Histogram of Beta(3,2)&quot;</span>)</span>
<span id="cb12-9"><a href="#cb12-9" tabindex="-1"></a>y <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.01</span>)</span>
<span id="cb12-10"><a href="#cb12-10" tabindex="-1"></a><span class="fu">lines</span>( y, <span class="fu">factorial</span>(a<span class="sc">+</span>b<span class="dv">-1</span>)<span class="sc">/</span>(<span class="fu">factorial</span>(a<span class="dv">-1</span>)<span class="sc">*</span><span class="fu">factorial</span>(b<span class="dv">-1</span>)) <span class="sc">*</span> y<span class="sc">^</span>(a<span class="dv">-1</span>) <span class="sc">*</span> (<span class="dv">1</span><span class="sc">-</span>y)<span class="sc">^</span>(b<span class="dv">-1</span>) )</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
<p>图像上红色部分是用acceptance-rejection method生成的<span class="math inline">\(Beta(3,2)\)</span>样本的直方图，随机样本的size为1000。此时，生成的样本分布很接近目标分布，但峰值还略有差别，真实分布的峰值更靠右。</p>
</div>
<div id="第三题" class="section level2">
<h2>第三题</h2>
<p><em>问题描述：</em> rescaled Epanechnikov kernel
是一个对称密度函数：<span class="math inline">\(f_e(x) =
\dfrac{3}{4}(1-x^2),~|x|\leq 1\)</span>。Devroye &amp;
Gyorfi给出了如下算法来模拟这一分布：生成服从均匀分布<span class="math inline">\(U(-1,1)\)</span>的三类独立同分布样本，分别记作<span class="math inline">\(U_1,~U_2,~U_3\)</span>；如果<span class="math inline">\(|U_3|\geq|U_2|\)</span>并且<span class="math inline">\(|U_3|\geq|U_1|\)</span>，产生<span class="math inline">\(U_2\)</span>，否则产生<span class="math inline">\(U_3\)</span>。写出一个函数，生成来自<span class="math inline">\(f_e\)</span>的随机变量，并绘制大型模拟随机样本的密度直方图。</p>
<p><em>思路：</em>
（1）以样本size作为函数的循环参数，以比较式作为循环条件，产生样本；
（2）绘制样本的直方图。</p>
<p>用Devroye &amp; Gyorfi给出的算法生成服从分布<span class="math inline">\(f_e(x)\)</span>的样本的<strong>R</strong>函数如下，其中，<code>n</code>为样本size：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb13-2"><a href="#cb13-2" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" tabindex="-1"></a>generate_fe <span class="ot">=</span> <span class="cf">function</span>(n){</span>
<span id="cb13-4"><a href="#cb13-4" tabindex="-1"></a>  k <span class="ot">=</span> <span class="dv">0</span> <span class="co"># counter for accept</span></span>
<span id="cb13-5"><a href="#cb13-5" tabindex="-1"></a>  j <span class="ot">=</span> <span class="dv">0</span> <span class="co"># iterations</span></span>
<span id="cb13-6"><a href="#cb13-6" tabindex="-1"></a>  fe_sample <span class="ot">=</span> <span class="fu">numeric</span>(n)</span>
<span id="cb13-7"><a href="#cb13-7" tabindex="-1"></a>  <span class="cf">while</span> (k <span class="sc">&lt;</span> n) {</span>
<span id="cb13-8"><a href="#cb13-8" tabindex="-1"></a>    u1 <span class="ot">=</span> <span class="fu">runif</span>(<span class="dv">1</span>, <span class="at">min =</span> <span class="sc">-</span><span class="dv">1</span>, <span class="at">max =</span> <span class="dv">1</span>)</span>
<span id="cb13-9"><a href="#cb13-9" tabindex="-1"></a>    u2 <span class="ot">=</span> <span class="fu">runif</span>(<span class="dv">1</span>, <span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb13-10"><a href="#cb13-10" tabindex="-1"></a>    u3 <span class="ot">=</span> <span class="fu">runif</span>(<span class="dv">1</span>, <span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb13-11"><a href="#cb13-11" tabindex="-1"></a>    k <span class="ot">=</span> k <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb13-12"><a href="#cb13-12" tabindex="-1"></a>    j <span class="ot">=</span> j <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb13-13"><a href="#cb13-13" tabindex="-1"></a>    <span class="cf">if</span> ( <span class="fu">abs</span>(u3)<span class="sc">&gt;=</span><span class="fu">abs</span>(u2) <span class="sc">&amp;</span> <span class="fu">abs</span>(u3)<span class="sc">&gt;=</span><span class="fu">abs</span>(u1) ){</span>
<span id="cb13-14"><a href="#cb13-14" tabindex="-1"></a>      <span class="co"># accept u2</span></span>
<span id="cb13-15"><a href="#cb13-15" tabindex="-1"></a>      fe_sample[k] <span class="ot">=</span> u2</span>
<span id="cb13-16"><a href="#cb13-16" tabindex="-1"></a>    }<span class="cf">else</span>{</span>
<span id="cb13-17"><a href="#cb13-17" tabindex="-1"></a>      fe_sample[k] <span class="ot">=</span> u3</span>
<span id="cb13-18"><a href="#cb13-18" tabindex="-1"></a>    }</span>
<span id="cb13-19"><a href="#cb13-19" tabindex="-1"></a>  }</span>
<span id="cb13-20"><a href="#cb13-20" tabindex="-1"></a>  <span class="fu">return</span>(fe_sample)</span>
<span id="cb13-21"><a href="#cb13-21" tabindex="-1"></a>}</span></code></pre></div>
<p>用自定义函数<code>generate_fe</code>生成服从分布<span class="math inline">\(f_e(x)\)</span>的10000个随机样本（认为10000是large
size），并画出样本直方图。</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1" tabindex="-1"></a>fe_Sample <span class="ot">=</span> <span class="fu">generate_fe</span>(<span class="dv">10000</span>)</span>
<span id="cb14-2"><a href="#cb14-2" tabindex="-1"></a></span>
<span id="cb14-3"><a href="#cb14-3" tabindex="-1"></a><span class="fu">hist</span>(fe_Sample, <span class="at">breaks=</span><span class="dv">30</span>, <span class="at">prob=</span><span class="cn">TRUE</span>, <span class="at">col=</span><span class="fu">rgb</span>(<span class="dv">1</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="fl">0.5</span>), <span class="at">xlab=</span><span class="st">&quot;sample&quot;</span>, </span>
<span id="cb14-4"><a href="#cb14-4" tabindex="-1"></a>     <span class="at">ylab=</span><span class="st">&quot;Density&quot;</span>, <span class="at">main =</span> <span class="st">&quot;Histogram of rescaled Epanechnikov kernel&quot;</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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9n4baXnK09cPrJHuo5uXJSerWH/dvJ2LXgaKotBkI93jQFHlQu46mAVONVR8ypgTjH+S2bcRZLOsYbJKCIAIARAhACIEQIQAiBAAEQIgQgBECIAIARAhACIEQIQAiBAAEQIgQgBECIAIARAhACIEQIQAiBAAEQIgQgBECIAIARCh0QGydljpRABECIAIDQjQ40qtXVFrWB5Xf98kyZqf3p4eX/60EovYBKCsZDFrZA0HkFgedmAs+CqobLFjJ9ifjC//zq4eGKatuMoByavdEBoOIL0A7PjdTtISCNSfreSR3ewZIPnR07BvDVbWcABZ71Lw9wa20qX0H7X8cLFjgOTqucBvClfVcADJPQhlA3P139U5oJdqbTMHpHZrmxsgrnSxM1z8gIKWPtbUwADx4vOadrisYmLprmqDOuzphwNI+MVBetBxw3rxM0B86a7Vi3Fn6yJbwwHEW2axOFes0bXrmgT0NzEeysdBHW2XOiBApeqoz7oUABECIEJjAdSbAIgQABECIEIARAiACAEQIQAiBECEAIgQABECIEIARAiACAEQIQAiBECEAIgQABECIEIAROhPqQmdMtYfJCcAAAAASUVORK5CYII=" /><!-- --></p>
<p>图像上红色部分是用Devroye &amp; Gyorfi给出的算法生成的rescaled
Epanechnikov
kernel样本的直方图，随机样本的size为10000。从直方图可以看出，该密度函数是对称的。</p>
</div>
<div id="第四题" class="section level2">
<h2>第四题</h2>
<p><em>问题描述：</em> 证明第三题中的算法可以生成服从<span class="math inline">\(f_e(x)\)</span>概率密度函数的随机数。</p>
<p><em>思路：</em>要证明生成的随机数的概率密度函数是rescaled
Epanechnikov kernel，只需证生成的随机数的分布函数与<span class="math inline">\(f_e(x)\)</span>的分布函数相同即可。</p>
<p>首先计算<span class="math inline">\(f_e(x)\)</span>的分布函数： <span class="math display">\[F_e(x) = \int _{-1}^x\dfrac{3}{4}(1-u^2)du =
-\dfrac{1}{4}x^3+\dfrac{3}{4}x+\dfrac{1}{2},~|x|&lt;1.\]</span>
接下来，计算生成的随机数<span class="math inline">\(U\)</span>的分布函数： <span class="math display">\[F_U(k) = P(U\leq k)\]</span> <span class="math display">\[= P(U_2\leq k|U=U_2)P(U=U_2)+P(U_3\leq
k|U=U_3)P(U=U_3)\]</span> <span class="math display">\[= P(U_2\leq
k,~U=U_2)+P(U_3\leq k,~U=U_3).\]</span> 此外，注意到<span class="math inline">\(U_1,~U_2,~U_3\)</span>独立同分布，因此有： <span class="math display">\[f(u_1,u_2,u_3)=f(u_1)f(u_2)f(u_3)=\dfrac{1}{8}.\]</span></p>
<p>分情况讨论，先考虑<span class="math inline">\(-1&lt;k&lt;0\)</span>：</p>
<p>（1）<span class="math inline">\(U=U_2\)</span>的条件是：<span class="math inline">\(|U_3|\geq|U_2|\)</span>并且<span class="math inline">\(|U_3|\geq|U_1|\)</span>，此时<span class="math inline">\(-1&lt;U_2&lt;k&lt;0\)</span>。若<span class="math inline">\(U_3&gt;0\)</span>，则有<span class="math inline">\(-U_3\leq U_1 \leq U_3\)</span>；若<span class="math inline">\(U_3\leq 0\)</span>，则有<span class="math inline">\(U_3\leq U_1 \leq -U_3\)</span>。因此： <span class="math display">\[P(U_2\leq k,~U=U_2)=\int_{-1}^k \int_{-U_2}^1
\int_{-U_3}^{U_3}f(u_1)f(u_2)f(u_3)du_1du_3du_2 \]</span> <span class="math display">\[+ \int_{-1}^k \int_{-1}^{U_2}
\int_{U_3}^{-U_3}f(u_1)f(u_2)f(u_3)du_1du_3du_2\]</span> <span class="math display">\[=-\dfrac{1}{12}k^3+\dfrac{1}{4}k+\dfrac{1}{6}.\]</span>
（2）<span class="math inline">\(U=U_3\)</span>的条件是：<span class="math inline">\(|U_3|&lt;|U_2|\)</span>并且<span class="math inline">\(|U_3|&lt;|U_1|\)</span>，或<span class="math inline">\(|U_3|\geq|U_2|\)</span>并且<span class="math inline">\(|U_3|&lt;|U_1|\)</span>，或<span class="math inline">\(|U_3|&lt;|U_2|\)</span>并且<span class="math inline">\(|U_3|\geq|U_1|\)</span>。此时<span class="math inline">\(-1&lt;U_3&lt;k&lt;0\)</span>。注意到<span class="math inline">\(|U_1|,~|U_2|,~|U_3|\)</span>独立且均服从均匀分布<span class="math inline">\(U(0,1)\)</span>。在之后的积分式中，将绝对值变换后的变量、密度函数用<span class="math inline">\(^*\)</span>标记。 <span class="math display">\[P(U_2\leq k,~U=U_2)=\int_{-1}^k \int_{-U_3}^1
\int_{-U_3}^{1}f^*(u_1^*)f^*(u_2^*)f(u_3)du_1^*du_2^*du_3\]</span> <span class="math display">\[+\int_{-1}^k \int_{0}^{-U_3}
\int_{-U_3}^{1}f^*(u_1^*)f^*(u_2^*)f(u_3)du_1^*du_2^*du_3\]</span> <span class="math display">\[+\int_{-1}^k \int_{-U_3}^{1} \int_{0}^{-U_3}
f^*(u_1^*)f^*(u_2^*)f(u_3)du_1^*du_2^*du_3\]</span> <span class="math display">\[=-\dfrac{1}{6}k^3+\dfrac{1}{2}k+\dfrac{1}{3}.\]</span>
其中，<span class="math inline">\(f^*(u_1^*)f^*(u_2^*)f(u_3)=\dfrac{1}{2}\)</span>.</p>
<p>因此，当<span class="math inline">\(-1&lt;k&lt;0\)</span>时， <span class="math display">\[F_U(k) =
(-\dfrac{1}{12}k^3+\dfrac{1}{4}k+\dfrac{1}{6})+(-\dfrac{1}{6}k^3+\dfrac{1}{2}k+\dfrac{1}{3})=-\dfrac{1}{4}k^3+\dfrac{3}{4}k+\dfrac{1}{2}.\]</span>
同理，当<span class="math inline">\(0\leq k&lt;1\)</span>时，也有 <span class="math display">\[F_U(k)
=-\dfrac{1}{4}k^3+\dfrac{3}{4}k+\dfrac{1}{2}.\]</span>
综上所述，我们证得了<span class="math inline">\(F_e(x)=F_U(x),~|x|&lt;1\)</span>，所以第三题中的算法可以生成服从<span class="math inline">\(f_e(x)\)</span>概率密度函数的随机数。</p>
</div>
<div id="复现sample函数" class="section level2">
<h2>复现sample函数</h2>
<p><em>问题描述：</em>
用逆变换法复现函数<code>sample</code>在参数<code>replace=TRUE</code>时的功能。</p>
<p><em>思路：</em>（1）函数参数应当包含抽样总体<code>x</code>，样本size<code>n</code>，抽样概率<code>prob</code>，以及随机种子<code>seed</code>；（2）<code>sample</code>函数在参数<code>replace=TRUE</code>时是有放回的随机抽样，相当于从离散总体中生成随机数，逆变换法步骤为：a.生成均匀分布随机数<span class="math inline">\(u\sim U(0,1)\)</span>，b.输入随机变量<span class="math inline">\(X\)</span>的分布<span class="math inline">\(F\)</span>，如果<span class="math inline">\(F(x_{i-1})\leq u&lt;F(x_{i})\)</span>，则输出<span class="math inline">\(X=x_i\)</span>。</p>
<p><strong>R</strong>函数的参数含义分别为：<code>x</code>是抽样总体，需要使用者输入一个长度<span class="math inline">\(\geq
1\)</span>的向量；参数<code>n</code>是样本size，默认为抽样总体的总数；参数<code>prob</code>是抽样概率，默认为等概率。</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" tabindex="-1"></a>my_sample <span class="ot">=</span> <span class="cf">function</span>(x, <span class="at">n =</span> <span class="fu">length</span>(x), <span class="at">prob =</span> <span class="fu">rep</span>(<span class="dv">1</span><span class="sc">/</span><span class="fu">length</span>(x), <span class="fu">length</span>(x))){</span>
<span id="cb15-2"><a href="#cb15-2" tabindex="-1"></a>  cp <span class="ot">=</span> <span class="fu">cumsum</span>(prob)</span>
<span id="cb15-3"><a href="#cb15-3" tabindex="-1"></a>  u <span class="ot">=</span> <span class="fu">runif</span>(n)</span>
<span id="cb15-4"><a href="#cb15-4" tabindex="-1"></a>  random_sample <span class="ot">=</span> x[<span class="fu">findInterval</span>(u,cp)<span class="sc">+</span><span class="dv">1</span>]</span>
<span id="cb15-5"><a href="#cb15-5" tabindex="-1"></a>  <span class="fu">return</span>(random_sample)</span>
<span id="cb15-6"><a href="#cb15-6" tabindex="-1"></a>}</span></code></pre></div>
<p>下面是用<code>my_sample</code>函数生成随机数的例子，与<code>sample</code>函数的结果进行比较。</p>
<p><strong>例1：在0-1总体中等概率抽样10个样本。</strong>
指定<code>my_sample</code>和<code>sample</code>两个函数的抽样总体和样本size。抽样概率是默认值<span class="math inline">\(0.5,0.5\)</span>，是有放回等概率抽样。</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1</span>)</span>
<span id="cb16-2"><a href="#cb16-2" tabindex="-1"></a>x <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">0</span>,<span class="dv">1</span>)</span>
<span id="cb16-3"><a href="#cb16-3" tabindex="-1"></a>n <span class="ot">=</span> <span class="dv">10</span></span>
<span id="cb16-4"><a href="#cb16-4" tabindex="-1"></a>s <span class="ot">=</span> <span class="fu">sample</span>(x, n, <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb16-5"><a href="#cb16-5" tabindex="-1"></a>ms <span class="ot">=</span> <span class="fu">my_sample</span>(x, n)</span>
<span id="cb16-6"><a href="#cb16-6" tabindex="-1"></a><span class="fu">print</span>(s)</span></code></pre></div>
<pre><code>##  [1] 0 1 0 0 1 0 0 0 1 1</code></pre>
<div class="sourceCode" id="cb18"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" tabindex="-1"></a><span class="fu">print</span>(ms)</span></code></pre></div>
<pre><code>##  [1] 0 0 1 0 1 0 1 1 0 1</code></pre>
<p><strong>例2：对英文字母进行重排。</strong>
指定<code>my_sample</code>和<code>sample</code>两个函数的抽样总体为<code>letters</code>。样本size是默认值，为抽样总体的总数。抽样概率是默认值，每一个字母抽中的概率是<span class="math inline">\(1/26\)</span>，是有放回等概率抽样。</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb20-1"><a href="#cb20-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">2</span>)</span>
<span id="cb20-2"><a href="#cb20-2" tabindex="-1"></a>x <span class="ot">=</span> letters</span>
<span id="cb20-3"><a href="#cb20-3" tabindex="-1"></a>s <span class="ot">=</span> <span class="fu">sample</span>(x,<span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb20-4"><a href="#cb20-4" tabindex="-1"></a>ms <span class="ot">=</span> <span class="fu">my_sample</span>(x)</span>
<span id="cb20-5"><a href="#cb20-5" tabindex="-1"></a><span class="fu">print</span>(s)</span></code></pre></div>
<pre><code>##  [1] &quot;u&quot; &quot;o&quot; &quot;f&quot; &quot;f&quot; &quot;h&quot; &quot;q&quot; &quot;q&quot; &quot;l&quot; &quot;i&quot; &quot;r&quot; &quot;k&quot; &quot;a&quot; &quot;c&quot; &quot;v&quot; &quot;p&quot; &quot;r&quot; &quot;s&quot; &quot;w&quot; &quot;h&quot;
## [20] &quot;g&quot; &quot;a&quot; &quot;v&quot; &quot;i&quot; &quot;p&quot; &quot;d&quot; &quot;k&quot;</code></pre>
<div class="sourceCode" id="cb22"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb22-1"><a href="#cb22-1" tabindex="-1"></a><span class="fu">print</span>(ms)</span></code></pre></div>
<pre><code>##  [1] &quot;e&quot; &quot;v&quot; &quot;w&quot; &quot;n&quot; &quot;q&quot; &quot;v&quot; &quot;h&quot; &quot;r&quot; &quot;d&quot; &quot;z&quot; &quot;h&quot; &quot;c&quot; &quot;e&quot; &quot;y&quot; &quot;u&quot; &quot;z&quot; &quot;j&quot; &quot;n&quot; &quot;v&quot;
## [20] &quot;a&quot; &quot;a&quot; &quot;r&quot; &quot;y&quot; &quot;h&quot; &quot;v&quot; &quot;u&quot;</code></pre>
<p><strong>例3：在1、2、3总体中不等概率抽样100个样本。</strong>
指定<code>my_sample</code>和<code>sample</code>两个函数的抽样总体、样本size为100、抽样概率为<span class="math inline">\(0.2, 0.3, 0.5\)</span>，是有放回不等概率抽样。</p>
<div class="sourceCode" id="cb24"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">3</span>)</span>
<span id="cb24-2"><a href="#cb24-2" tabindex="-1"></a>x <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>)</span>
<span id="cb24-3"><a href="#cb24-3" tabindex="-1"></a>n <span class="ot">=</span> <span class="dv">100</span></span>
<span id="cb24-4"><a href="#cb24-4" tabindex="-1"></a>prob <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">0.2</span>, <span class="fl">0.3</span>, <span class="fl">0.5</span>)</span>
<span id="cb24-5"><a href="#cb24-5" tabindex="-1"></a>s <span class="ot">=</span> <span class="fu">sample</span>(x, n, prob, <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb24-6"><a href="#cb24-6" tabindex="-1"></a>ms <span class="ot">=</span> <span class="fu">my_sample</span>(x, n, prob)</span>
<span id="cb24-7"><a href="#cb24-7" tabindex="-1"></a>count_sample <span class="ot">&lt;-</span> <span class="fu">as.vector</span>(<span class="fu">table</span>(s))</span>
<span id="cb24-8"><a href="#cb24-8" tabindex="-1"></a>count_my_sample <span class="ot">&lt;-</span> <span class="fu">as.vector</span>(<span class="fu">table</span>(ms))</span>
<span id="cb24-9"><a href="#cb24-9" tabindex="-1"></a><span class="fu">print</span>(count_sample)</span></code></pre></div>
<pre><code>## [1] 20 29 51</code></pre>
<div class="sourceCode" id="cb26"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" tabindex="-1"></a><span class="fu">print</span>(count_my_sample)</span></code></pre></div>
<pre><code>## [1] 21 32 47</code></pre>
<p>从以上三个例子的结果可以看出，<code>my_sample</code>函数能够实现<code>sample</code>在参数<code>replace=TRUE</code>时的功能。虽然结果有细微差别，但当样本size足够大时，抽样结果更加接近。</p>
</div>
</div>
<div id="hw2" class="section level1">
<h1>HW2</h1>
<div id="第一题-1" class="section level2">
<h2>第一题</h2>
<p><em>问题描述：</em>（1）在Buffon’s niddle
experiment中，找一个最优的<span class="math inline">\(\dfrac{l}{d}=\rho\)</span>，使得<span class="math inline">\(\hat \pi=\dfrac{2l}{d\hat
p}\)</span>的渐近方差最小，其中<span class="math inline">\(\hat
p=\dfrac{m}{n}\)</span>（提示：使用<span class="math inline">\(\delta\)</span>法，<span class="math inline">\(m\sim B(n,p)\)</span>）。记最优的<span class="math inline">\(\rho\)</span>为<span class="math inline">\(\rho_{\min}\)</span>。（2）取三个不同的<span class="math inline">\(\rho\)</span>值（<span class="math inline">\(0\leq\rho\leq1\)</span>，包含<span class="math inline">\(\rho_{\min}\)</span>），用MC方法比较计算出的<span class="math inline">\(\hat
\pi\)</span>的方差，以验证上一题的结论。（<span class="math inline">\(n=10^6,~K=100\)</span>）</p>
<p><em>思路：</em>（1）用delta法写出<span class="math inline">\(\hat
\pi\)</span>的表达式，该表达式和<span class="math inline">\(\rho\)</span>有关，再求最小值。（2）取<span class="math inline">\(\rho_1=\rho_{\min}=1,\rho_2=0.8,\rho_3=0.5\)</span>，用MC方法生成<span class="math inline">\(\hat \pi\)</span>，再计算方差。</p>
<p>解：已知<span class="math inline">\(m\sim B(n,p)\)</span>，<span class="math inline">\(\hat \pi=\dfrac{2l}{d\hat
p}=\dfrac{2ln}{dm}\)</span>。由delta法： <span class="math display">\[Var(\hat
\pi)=\dfrac{4\rho^2(1-p)}{np^3}.\]</span> 注意到<span class="math inline">\(p=\dfrac{2\rho}{\pi}\)</span>，代入到上式： <span class="math display">\[Var(\hat
\pi)=\dfrac{4\rho^2(1-\dfrac{2\rho}{\pi})}{n(\dfrac{2\rho}{\pi})^3}=\dfrac{\pi^2}{n}(\dfrac{\pi}{2\rho}-1).\]</span>
由于<span class="math inline">\(0\leq\rho\leq1\)</span>，因此<span class="math inline">\(\rho=1\)</span>时<span class="math inline">\(\hat
\pi\)</span>的渐近方差最小。<span class="math inline">\(\rho_{\min}=1\)</span>，<span class="math inline">\(Var(\hat
\pi)_{\min}=\dfrac{\pi^2(\pi-2)}{2n}.\)</span></p>
<p>分别取<span class="math inline">\(\rho_1=1,\rho_2=0.8,\rho_3=0.5\)</span>，线段间距<span class="math inline">\(d\)</span>设置为2，对应的针长<span class="math inline">\(l\)</span>分别是<span class="math inline">\(2,~1.6,~1\)</span>。<span class="math inline">\(\hat \pi\)</span>的估计式为： <span class="math display">\[\hat \pi=
\dfrac{2l}{d}\dfrac{n}{I(\frac{l}{2}\sin(Y)&gt;X)},\]</span> 其中，<span class="math inline">\(Y\sim U(0,\pi/2)\)</span>，<span class="math inline">\(X\sim
U(0,d/2)\)</span>。用MC方法进行模拟，计算<span class="math inline">\(\hat \pi\)</span>及其方差的代码如下：</p>
<div class="sourceCode" id="cb28"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" tabindex="-1"></a>n <span class="ot">=</span> <span class="fl">1e6</span></span>
<span id="cb28-2"><a href="#cb28-2" tabindex="-1"></a>K <span class="ot">=</span> <span class="dv">100</span></span>
<span id="cb28-3"><a href="#cb28-3" tabindex="-1"></a>l <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="fl">1.6</span>, <span class="dv">1</span>)</span>
<span id="cb28-4"><a href="#cb28-4" tabindex="-1"></a>d <span class="ot">=</span> <span class="dv">2</span></span>
<span id="cb28-5"><a href="#cb28-5" tabindex="-1"></a>pihat <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="fu">matrix</span>(<span class="cn">NA</span>, K, <span class="dv">3</span>))</span>
<span id="cb28-6"><a href="#cb28-6" tabindex="-1"></a></span>
<span id="cb28-7"><a href="#cb28-7" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>) {</span>
<span id="cb28-8"><a href="#cb28-8" tabindex="-1"></a>  <span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>K){</span>
<span id="cb28-9"><a href="#cb28-9" tabindex="-1"></a>    <span class="fu">set.seed</span>(j)</span>
<span id="cb28-10"><a href="#cb28-10" tabindex="-1"></a>    X <span class="ot">=</span> <span class="fu">runif</span>(n,<span class="dv">0</span>,d<span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb28-11"><a href="#cb28-11" tabindex="-1"></a>    Y <span class="ot">=</span> <span class="fu">runif</span>(n,<span class="dv">0</span>,pi<span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb28-12"><a href="#cb28-12" tabindex="-1"></a>    pihat[j,i] <span class="ot">=</span> <span class="dv">2</span><span class="sc">*</span>l[i]<span class="sc">/</span>d<span class="sc">/</span><span class="fu">mean</span>(l[i]<span class="sc">/</span><span class="dv">2</span><span class="sc">*</span><span class="fu">sin</span>(Y)<span class="sc">&gt;</span>X)</span>
<span id="cb28-13"><a href="#cb28-13" tabindex="-1"></a>  }</span>
<span id="cb28-14"><a href="#cb28-14" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb29"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" tabindex="-1"></a><span class="co"># 计算方差</span></span>
<span id="cb29-2"><a href="#cb29-2" tabindex="-1"></a>var <span class="ot">=</span> <span class="fu">apply</span>(pihat, <span class="dv">2</span>, var)</span></code></pre></div>
<p>当<span class="math inline">\(\rho\)</span>分别为1, 0.8, 0.5时，<span class="math inline">\(\hat \pi\)</span>的方差如表1所示。<span class="math inline">\(\rho=1\)</span>时的方差最小，为<span class="math inline">\(4.5\times 10^{-6}\)</span>，符合第一问的结论。</p>
</div>
<div id="第二题-1" class="section level2">
<h2>第二题</h2>
<p><em>问题描述：</em>例5.7说明了求解蒙特卡洛积分的控制变量法： <span class="math display">\[\theta = \int_0^1e^xdx.\]</span>
现考虑对偶变量法，计算<span class="math inline">\(Cov(e^U,e^{1-U})\)</span>以及<span class="math inline">\(Var(e^U+e^{1-U})\)</span>，其中<span class="math inline">\(U\sim
Uniform(0,1)\)</span>。与简单MC方法相比，对偶法能降低百分之多少的方差？</p>
<p><em>思路：</em>分别用简单MC方法和对偶变量法计算<span class="math inline">\(\hat
\theta\)</span>及其方差，并计算方差降低的百分比。</p>
<p>解：在简单MC方法中，有<span class="math inline">\(\theta =
E[g(U)]\)</span>，其中<span class="math inline">\(g(U)=e^U\)</span>，<span class="math inline">\(U\sim U(0,1)\)</span>。 考虑对偶变量，<span class="math inline">\(e^{1-U}\)</span>与<span class="math inline">\(e^U\)</span>负相关且同分布： <span class="math display">\[Cov(e^U, e^{1-U}) =
E[e^Ue^{1-U}]-E[e^U]E[e^{1-U}]\]</span> <span class="math display">\[ =
e-(e-1)(e-1)\]</span> <span class="math display">\[ =
-e^2+3e-1.\]</span> 将<span class="math inline">\(Cov(e^U,
e^{1-U})\)</span>代入到方差计算式中： <span class="math display">\[Var(e^U+e^{1-U}) = Var(e^U) + Var(e^{1-U}) +
2Cov(e^U, e^{1-U})\]</span> <span class="math display">\[ =
\dfrac{1}{2}(-e^2+4e-3)\times 2 + 2\times(-e^2+3e-1)\]</span> <span class="math display">\[ = -3e^2+10e-5.\]</span> 而<span class="math inline">\(Var(e^U)=\dfrac{1}{2}(-e^2+4e-3)\)</span>，计算方差降低的百分比：
<span class="math display">\[\dfrac{Var(e^U)-\dfrac{1}{2}Var(e^U+e^{1-U})}{Var(e^U)}=\dfrac{\dfrac{1}{2}(-e^2+4e-3)-\dfrac{1}{2}(-3e^2+10e-5)}{\dfrac{1}{2}(-e^2+4e-3)}\]</span>
<span class="math display">\[=\dfrac{(-e^2+4e-3)-(-3e^2+10e-5)}{-e^2+4e-3}\]</span>
<span class="math display">\[=\dfrac{2e^2-6e+2}{-e^2+4e-3}\]</span>
<span class="math display">\[\approx 0.9677.\]</span>
与简单MC方法相比，对偶法能降低约96.77%的方差。</p>
</div>
<div id="第三题-1" class="section level2">
<h2>第三题</h2>
<p><em>问题描述：</em>参考上一题，分别用对偶变量法和简单MC法估计<span class="math inline">\(\theta\)</span>。计算使用对偶法带来的方差减少百分比的经验估计，将结果与上一题中的理论值进行比较。</p>
<p><em>思路：</em>首先生成0-1区间上均匀分布的随机数，计算<span class="math inline">\(e^U\)</span>与<span class="math inline">\(e^{1-U}\)</span>的值，分别用对偶变量法和简单MC法估计<span class="math inline">\(\theta\)</span>。再计算两种方法的方差，以及方差降低的百分比。</p>
<p>解：我们首先将对偶变量法和简单MC法的生成随机数机制写成函数<code>MC_anti</code>。然后进行100次模拟，每次生成10000个随机数，用于估计<span class="math inline">\(\theta\)</span>。<strong>R</strong>代码如下：</p>
<div class="sourceCode" id="cb30"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" tabindex="-1"></a><span class="co"># 函数参数：生成的随机数数量，是否要用对偶变量法</span></span>
<span id="cb30-2"><a href="#cb30-2" tabindex="-1"></a><span class="co"># 函数功能：如果要用对偶变量法，1/2的随机数要做变换；否则不用做变换，即简单MC法</span></span>
<span id="cb30-3"><a href="#cb30-3" tabindex="-1"></a>MC_anti <span class="ot">=</span> <span class="cf">function</span>(n, <span class="at">antithetic =</span> <span class="cn">TRUE</span>){</span>
<span id="cb30-4"><a href="#cb30-4" tabindex="-1"></a>  u <span class="ot">=</span> <span class="fu">runif</span>(n<span class="sc">/</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb30-5"><a href="#cb30-5" tabindex="-1"></a>  <span class="cf">if</span>(<span class="sc">!</span>antithetic) v <span class="ot">=</span> <span class="fu">runif</span>(n<span class="sc">/</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">1</span>) <span class="cf">else</span></span>
<span id="cb30-6"><a href="#cb30-6" tabindex="-1"></a>    v <span class="ot">=</span> <span class="dv">1</span> <span class="sc">-</span> u </span>
<span id="cb30-7"><a href="#cb30-7" tabindex="-1"></a>  u <span class="ot">=</span> <span class="fu">c</span>(u, v)</span>
<span id="cb30-8"><a href="#cb30-8" tabindex="-1"></a>  theta <span class="ot">=</span> <span class="fu">mean</span>(<span class="fu">exp</span>(u))</span>
<span id="cb30-9"><a href="#cb30-9" tabindex="-1"></a>  theta</span>
<span id="cb30-10"><a href="#cb30-10" tabindex="-1"></a>}</span>
<span id="cb30-11"><a href="#cb30-11" tabindex="-1"></a></span>
<span id="cb30-12"><a href="#cb30-12" tabindex="-1"></a><span class="co"># 开始计算theta及其方差</span></span>
<span id="cb30-13"><a href="#cb30-13" tabindex="-1"></a>K <span class="ot">=</span> <span class="dv">100</span></span>
<span id="cb30-14"><a href="#cb30-14" tabindex="-1"></a>n <span class="ot">=</span> <span class="dv">10000</span></span>
<span id="cb30-15"><a href="#cb30-15" tabindex="-1"></a>theta_simple <span class="ot">=</span> theta_anti <span class="ot">=</span> <span class="fu">numeric</span>(K)</span>
<span id="cb30-16"><a href="#cb30-16" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>K) {</span>
<span id="cb30-17"><a href="#cb30-17" tabindex="-1"></a>  <span class="fu">set.seed</span>(i)</span>
<span id="cb30-18"><a href="#cb30-18" tabindex="-1"></a>  theta_simple[i] <span class="ot">=</span> <span class="fu">MC_anti</span>(n, <span class="at">antithetic =</span> <span class="cn">FALSE</span>)</span>
<span id="cb30-19"><a href="#cb30-19" tabindex="-1"></a>  theta_anti[i] <span class="ot">=</span> <span class="fu">MC_anti</span>(n, <span class="at">antithetic =</span> <span class="cn">TRUE</span>)</span>
<span id="cb30-20"><a href="#cb30-20" tabindex="-1"></a>}</span>
<span id="cb30-21"><a href="#cb30-21" tabindex="-1"></a>var_simple <span class="ot">=</span> <span class="fu">var</span>(theta_simple)</span>
<span id="cb30-22"><a href="#cb30-22" tabindex="-1"></a>var_anti <span class="ot">=</span> <span class="fu">var</span>(theta_anti)</span>
<span id="cb30-23"><a href="#cb30-23" tabindex="-1"></a><span class="fu">print</span>(var_simple)</span></code></pre></div>
<pre><code>## [1] 2.061706e-05</code></pre>
<div class="sourceCode" id="cb32"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" tabindex="-1"></a><span class="fu">print</span>(var_anti)</span></code></pre></div>
<pre><code>## [1] 5.645978e-07</code></pre>
<div class="sourceCode" id="cb34"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" tabindex="-1"></a><span class="fu">print</span>((var_simple<span class="sc">-</span>var_anti)<span class="sc">/</span>var_simple)</span></code></pre></div>
<pre><code>## [1] 0.972615</code></pre>
<p>与简单MC方法相比，对偶法带来的方差减少的经验估计值为97.26%。该结果比上一题的理论值（96.77%）略高，这可能是由模拟的随机性所导致的。</p>
</div>
</div>
<div id="hw3" class="section level1">
<h1>HW3</h1>
<div id="第一题-2" class="section level2">
<h2>第一题</h2>
<p><em>问题描述：</em> 在Stratified Sampling问题中，记区间<span class="math inline">\(I\)</span>被分割为<span class="math inline">\((a_i,b_i),~i=1,...k\)</span>，简单估计的方差为<span class="math inline">\(Var(\hat{\theta^M})\)</span>，分层估计的方差为<span class="math inline">\(Var(\hat{\theta^S})\)</span>，且 <span class="math display">\[Var(\hat{\theta^M}) =
\dfrac{1}{Mk}\sum_{i=1}^k\sigma_i^2+\dfrac{1}{M}Var(\theta_I) =
Var(\hat{\theta^S})+\dfrac{1}{M}Var(\theta_I).\]</span> 证明：若<span class="math inline">\(g\)</span>是<span class="math inline">\((a,b)\)</span>上的连续函数，当<span class="math inline">\(\forall i \in \{1,...k\},~b_i-a_i\rightarrow
0\)</span>，<span class="math inline">\(Var(\hat{\theta^S})/Var(\hat{\theta^M})\rightarrow
0\)</span>.</p>
<p><em>思路：</em> 按照<span class="math inline">\(Var(\hat{\theta^M})\)</span>与<span class="math inline">\(Var(\hat{\theta^S})\)</span>之间的关系式化简<span class="math inline">\(Var(\hat{\theta^S})/Var(\hat{\theta^M})\rightarrow
0\)</span>，将问题转化为对<span class="math inline">\(\dfrac{1}{Mk}\sum_{i=1}^k\sigma_i^2\)</span>的分析。再根据定义写出<span class="math inline">\(\dfrac{1}{Mk}\sum_{i=1}^k\sigma_i^2\)</span>的表达式，将积分内部放大为与<span class="math inline">\(u\)</span>无关的项，从而利用<span class="math inline">\(b_i-a_i\rightarrow 0\)</span>的条件证明。</p>
<p><em>证明：</em> 由<span class="math inline">\(Var(\hat{\theta^M}) =
\dfrac{1}{Mk}\sum_{i=1}^k\sigma_i^2+Var(\theta_I) =
Var(\hat{\theta^S})+Var(\theta_I)\)</span>知， <span class="math display">\[\dfrac{Var(\hat{\theta^S})}{Var(\hat{\theta^M})}
=
\dfrac{\frac{1}{Mk}\sum_{i=1}^k\sigma_i^2}{\frac{1}{Mk}\sum_{i=1}^k\sigma_i^2+Var(\theta_I)}\]</span>
<span class="math display">\[=
\dfrac{1}{1+\dfrac{\frac{1}{M}Var(\theta_I)}{\frac{1}{Mk}\sum_{i=1}^k\sigma_i^2}}\]</span>
<span class="math display">\[=
\dfrac{1}{1+\dfrac{Var(\theta_I)}{\frac{1}{k}\sum_{i=1}^k\sigma_i^2}}.\]</span>
由于<span class="math inline">\(b_i-a_i\rightarrow 0\)</span>时，<span class="math inline">\(\theta_i\rightarrow g(U)\)</span>。而<span class="math inline">\(g\)</span>是连续函数，因此<span class="math inline">\(Var(\theta_I)\rightarrow Var(
g(U))&lt;\infty\)</span>，所以接下来只需证<span class="math inline">\(\frac{1}{k}\sum_{i=1}^k\sigma_i^2\rightarrow
0\)</span>即可。</p>
<p>根据<span class="math inline">\(\sigma_i^2\)</span>的定义，有： <span class="math display">\[\frac{1}{k}\sum_{i=1}^k\sigma_i^2 =
\frac{1}{k}\sum_{i=1}^k\int_{a_i}^{b_i}\dfrac{1}{b_i-a_i}(g(u)-\bar{g(u)})^2du\]</span>
记<span class="math inline">\(\Delta g_i =
g_{\max}(u)-g_{\min}(u),~u\in[a_i,b_i]\)</span>，显然有<span class="math inline">\((g(u)-\bar{g(u)})^2&lt;(\Delta
g_i)^2\)</span>。所以： <span class="math display">\[\frac{1}{k}\sum_{i=1}^k\sigma_i^2 &lt;
\frac{1}{k}\sum_{i=1}^k\int_{a_i}^{b_i}\dfrac{1}{b_i-a_i}(\Delta
g_i)^2du\]</span> <span class="math display">\[=
\frac{1}{k}\sum_{i=1}^k(b_i-a_i)\dfrac{1}{b_i-a_i}(\Delta
g_i)^2,\]</span> <span class="math display">\[\leq
\frac{1}{k}\sum_{i=1}^k(b_i-a_i)\dfrac{1}{b_i-a_i}\max(\Delta
g_i)^2,\]</span> 又由于<span class="math inline">\(g(x)\)</span>是连续的，因此<span class="math inline">\(b_i-a_i\rightarrow 0\)</span>时，<span class="math inline">\(\max(\Delta g_i)^2\rightarrow 0\)</span>。从而有：
<span class="math display">\[\frac{1}{k}\sum_{i=1}^k\sigma_i^2
\rightarrow 0.\]</span> 至此，我们证得，当<span class="math inline">\(b_i-a_i\rightarrow 0\)</span>时： <span class="math display">\[\dfrac{Var(\hat{\theta^S})}{Var(\hat{\theta^M})}
=
\dfrac{\frac{1}{Mk}\sum_{i=1}^k\sigma_i^2}{\frac{1}{Mk}\sum_{i=1}^k\sigma_i^2+Var(\theta_I)}\rightarrow
0.\]</span></p>
</div>
<div id="第二题-2" class="section level2">
<h2>第二题</h2>
<p><em>问题描述：</em> 找到以<span class="math inline">\((1,\infty)\)</span>为支撑并且“接近”<span class="math inline">\(g(x)\)</span>的两个importance functions <span class="math inline">\(f_1\)</span>和<span class="math inline">\(f_2\)</span>， <span class="math display">\[g(x)=\dfrac{x^2}{\sqrt{2\pi}}e^{-x^2/2},~x&gt;1.\]</span>
其中哪个function能够在用importance sampling方法估计<span class="math inline">\(\int_1^{\infty}g(x)dx\)</span>的时候有更小的方差？解释原因。</p>
<p><em>思路：</em> importance function是易于生成，并且与<span class="math inline">\(g(x)\)</span>有较高的相关性（最好比值接近于常数）的密度函数。按照该思路构造<span class="math inline">\(f\)</span>，在支撑集上，<span class="math inline">\(f\)</span>与<span class="math inline">\(g(x)\)</span>的比值越接近常数，其方差越小。</p>
<p><em>解：</em> 以<span class="math inline">\((1,\infty)\)</span>为支撑的两个importance
functions如下所示，它们在<span class="math inline">\((1,\infty)\)</span>上积分值为1，符合密度函数的定义：
<span class="math display">\[f_1(x) = e^{-(x-1)},~x&gt;1,\]</span> <span class="math display">\[f_2(x) = \dfrac{1}{2}x^{-3/2 },~x&gt;1.\]</span>
其中，<span class="math inline">\(f_1(x)\)</span>在用importance
sampling方法估计<span class="math inline">\(\int_1^{\infty}g(x)dx\)</span>的时候有更小的方差。下面分别从理论和数值模拟两个方面进行说明：</p>
<p>（1） 理论推导： 设<span class="math inline">\(x\)</span>的概率密度函数为<span class="math inline">\(f(x)\)</span>，则积分值 <span class="math display">\[\theta = \int_1^{\infty}g(x)dx =
\int_1^{\infty}\dfrac{g(x)}{f(x)}f(x)dx =
E[\dfrac{g(x)}{f(x)}],\]</span> 从<span class="math inline">\(X\)</span>的分布中生成<span class="math inline">\(X_1,...X_n\)</span>个独立随机变量，积分的MC估计值为：
<span class="math display">\[\hat \theta = \bar{g(X)}
=\dfrac{1}{n}\sum_{i=1}^n\dfrac{g(x)}{f(x)}.\]</span> 由上式可知，<span class="math inline">\(\dfrac{g(x)}{f(x)}\)</span>越接近常数，<span class="math inline">\(\hat \theta\)</span>的方差越小。而<span class="math inline">\(f_1(x) = e^{-(x-1)}\)</span>比<span class="math inline">\(f_2(x) = \dfrac{1}{2}x^{-3/2
}\)</span>更满足这一点，因此<span class="math inline">\(f_1\)</span>在用importance sampling方法估计<span class="math inline">\(\int_1^{\infty}g(x)dx\)</span>的时候有更小的方差。</p>
<p>如图所示，图(A)分别是<span class="math inline">\(g(x)\)</span>，<span class="math inline">\(f_1(x)\)</span>，<span class="math inline">\(f_2(x)\)</span>在<span class="math inline">\((1,6)\)</span>上的图像。图(B)分别是<span class="math inline">\(g(x)/f_1(x)\)</span>，<span class="math inline">\(g(x)/f_2(x)\)</span>在<span class="math inline">\((1,6)\)</span>上的图像。从图(B)可以看出，<span class="math inline">\(\dfrac{g(x)}{f_1(x)}\)</span>更接近常数。</p>
<p><img src="data:image/png;base64,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" /><!-- --><img src="data:image/png;base64,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" /><!-- --></p>
<p>（2）数值模拟： 分别生成<span class="math inline">\(10^6\)</span>个<span class="math inline">\(g(x)/f_1(x)\)</span>与<span class="math inline">\(g(x)/f_2(x)\)</span>，计算积分估计值及标准误。<span class="math inline">\(f_1(x)\)</span>的标准误小于<span class="math inline">\(f_2(x)\)</span>，为0.157。</p>
</div>
<div id="第三题-2" class="section level2">
<h2>第三题</h2>
<p><em>问题描述：</em> 用importance sampling方法计算<span class="math inline">\(\int_1^{\infty}\dfrac{x^2}{\sqrt{2\pi}}e^{-x^2/2}dx\)</span>的MC估计。</p>
<p><em>解：</em> 积分的MC估计值为： <span class="math display">\[\hat
\theta = \bar{g(X)}
=\dfrac{1}{n}\sum_{i=1}^n\dfrac{g(x)}{f(x)}.\]</span>
根据上一题的分析，我们选择importance functions： <span class="math display">\[f_(x) = e^{-(x-1)},~x&gt;1,\]</span>
计算的代码及结果如下：</p>
<div class="sourceCode" id="cb36"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb36-1"><a href="#cb36-1" tabindex="-1"></a>m <span class="ot">&lt;-</span> <span class="fl">1e6</span></span>
<span id="cb36-2"><a href="#cb36-2" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb36-3"><a href="#cb36-3" tabindex="-1"></a>g <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb36-4"><a href="#cb36-4" tabindex="-1"></a>  x<span class="sc">^</span><span class="dv">2</span> <span class="sc">/</span> <span class="fu">sqrt</span>(<span class="dv">2</span><span class="sc">*</span>pi) <span class="sc">*</span> <span class="fu">exp</span>(<span class="sc">-</span>x<span class="sc">^</span><span class="dv">2</span><span class="sc">/</span><span class="dv">2</span>) <span class="sc">*</span> (x <span class="sc">&gt;</span> <span class="dv">1</span>)</span>
<span id="cb36-5"><a href="#cb36-5" tabindex="-1"></a>}</span>
<span id="cb36-6"><a href="#cb36-6" tabindex="-1"></a>f1 <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {<span class="fu">exp</span>(<span class="sc">-</span>(x<span class="dv">-1</span>))<span class="sc">*</span> (x <span class="sc">&gt;</span> <span class="dv">1</span>)}</span>
<span id="cb36-7"><a href="#cb36-7" tabindex="-1"></a></span>
<span id="cb36-8"><a href="#cb36-8" tabindex="-1"></a>u <span class="ot">=</span> <span class="fu">runif</span>(m)</span>
<span id="cb36-9"><a href="#cb36-9" tabindex="-1"></a>x <span class="ot">=</span> <span class="dv">1</span> <span class="sc">-</span> <span class="fu">log</span>(<span class="dv">1</span><span class="sc">-</span>u)</span>
<span id="cb36-10"><a href="#cb36-10" tabindex="-1"></a>est <span class="ot">&lt;-</span> <span class="fu">mean</span>(<span class="fu">g</span>(x)<span class="sc">/</span><span class="fu">f1</span>(x))</span>
<span id="cb36-11"><a href="#cb36-11" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&#39;g(x)的MC估计为：&#39;</span>, est)</span></code></pre></div>
<pre><code>## g(x)的MC估计为： 0.4004642</code></pre>
</div>
<div id="第四题-1" class="section level2">
<h2>第四题</h2>
<p><em>问题描述：</em> 计算例5.13的stratified importance sampling
estimate，与例5.10的结果比较一下。</p>
<p><em>思路：</em> 先将<span class="math inline">\(x\)</span>的区间均匀分成五段，根据每一段区间上的importance
function，计算区间上的积分值，然后相加得到最终结果。</p>
<p><em>解：</em> 为估计积分值： <span class="math display">\[\theta =
\int_0^1\dfrac{e^{-x}}{1+x^2}dx,\]</span> 我们选择的importance
function为： <span class="math display">\[f(x) =
\dfrac{e^{-x}}{1-e^{-1}},~0&lt;x&lt;1.\]</span> 将<span class="math inline">\((0,1)\)</span>区间均匀分成五段后，第<span class="math inline">\(j\)</span>区间上的importance function为： <span class="math display">\[f_j(x) =
\dfrac{5e^{-x}}{1-e^{-1}},~\dfrac{j-1}{5}&lt;x&lt;\dfrac{j}{5}.\]</span>
而积分的估计值为： <span class="math display">\[\hat{\theta}_{SI} =
\dfrac{1}{5}\sum_{j=1}^5\hat{\theta_j}.\]</span> stratified importance
sampling计算积分估计值及标准差的代码及结果如下：</p>
<div class="sourceCode" id="cb38"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" tabindex="-1"></a>m <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb38-2"><a href="#cb38-2" tabindex="-1"></a>theta_j <span class="ot">=</span> <span class="fu">numeric</span>(<span class="dv">5</span>)</span>
<span id="cb38-3"><a href="#cb38-3" tabindex="-1"></a>theta_SI <span class="ot">=</span> <span class="fu">numeric</span>(<span class="dv">10</span>)</span>
<span id="cb38-4"><a href="#cb38-4" tabindex="-1"></a>g <span class="ot">=</span> <span class="cf">function</span>(x){</span>
<span id="cb38-5"><a href="#cb38-5" tabindex="-1"></a>  <span class="fu">exp</span>(<span class="sc">-</span>x <span class="sc">-</span> <span class="fu">log</span>(<span class="dv">1</span><span class="sc">+</span>x<span class="sc">^</span><span class="dv">2</span>))<span class="sc">*</span>(x<span class="sc">&lt;</span><span class="dv">1</span>)<span class="sc">*</span>(x<span class="sc">&gt;</span><span class="dv">0</span>)</span>
<span id="cb38-6"><a href="#cb38-6" tabindex="-1"></a>}</span>
<span id="cb38-7"><a href="#cb38-7" tabindex="-1"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">10</span>){</span>
<span id="cb38-8"><a href="#cb38-8" tabindex="-1"></a>  <span class="fu">set.seed</span>(i)</span>
<span id="cb38-9"><a href="#cb38-9" tabindex="-1"></a>  theta_j[<span class="dv">1</span>] <span class="ot">=</span> <span class="fu">mean</span>(<span class="fu">g</span>(<span class="fu">runif</span>(m<span class="sc">/</span><span class="dv">5</span>, <span class="dv">0</span>, <span class="fl">0.2</span>)))</span>
<span id="cb38-10"><a href="#cb38-10" tabindex="-1"></a>  theta_j[<span class="dv">2</span>] <span class="ot">=</span> <span class="fu">mean</span>(<span class="fu">g</span>(<span class="fu">runif</span>(m<span class="sc">/</span><span class="dv">5</span>, <span class="fl">0.2</span>, <span class="fl">0.4</span>)))</span>
<span id="cb38-11"><a href="#cb38-11" tabindex="-1"></a>  theta_j[<span class="dv">3</span>] <span class="ot">=</span> <span class="fu">mean</span>(<span class="fu">g</span>(<span class="fu">runif</span>(m<span class="sc">/</span><span class="dv">5</span>, <span class="fl">0.4</span>, <span class="fl">0.6</span>)))</span>
<span id="cb38-12"><a href="#cb38-12" tabindex="-1"></a>  theta_j[<span class="dv">4</span>] <span class="ot">=</span> <span class="fu">mean</span>(<span class="fu">g</span>(<span class="fu">runif</span>(m<span class="sc">/</span><span class="dv">5</span>, <span class="fl">0.6</span>, <span class="fl">0.8</span>)))</span>
<span id="cb38-13"><a href="#cb38-13" tabindex="-1"></a>  theta_j[<span class="dv">5</span>] <span class="ot">=</span> <span class="fu">mean</span>(<span class="fu">g</span>(<span class="fu">runif</span>(m<span class="sc">/</span><span class="dv">5</span>, <span class="fl">0.8</span>, <span class="dv">1</span>)))</span>
<span id="cb38-14"><a href="#cb38-14" tabindex="-1"></a>  theta_SI[i] <span class="ot">=</span> <span class="fu">mean</span>(theta_j)</span>
<span id="cb38-15"><a href="#cb38-15" tabindex="-1"></a>}</span>
<span id="cb38-16"><a href="#cb38-16" tabindex="-1"></a>mu <span class="ot">=</span> <span class="fu">mean</span>(theta_SI)</span>
<span id="cb38-17"><a href="#cb38-17" tabindex="-1"></a>sd <span class="ot">=</span> <span class="fu">sd</span>(theta_SI)</span>
<span id="cb38-18"><a href="#cb38-18" tabindex="-1"></a></span>
<span id="cb38-19"><a href="#cb38-19" tabindex="-1"></a>mu</span></code></pre></div>
<pre><code>## [1] 0.52468</code></pre>
<div class="sourceCode" id="cb40"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb40-1"><a href="#cb40-1" tabindex="-1"></a>sd</span></code></pre></div>
<pre><code>## [1] 0.0009556493</code></pre>
<p>例5.10的结果是<span class="math inline">\(\hat{\theta} =
0.5258\)</span>，<span class="math inline">\(sd(\hat{\theta})=0.0970\)</span>。与本题结果相比，积分的估计值接近，但本题的标准差小得多。</p>
</div>
<div id="第五题" class="section level2">
<h2>第五题</h2>
<p><em>问题描述：</em>
假设使用95%的对称t区间来估计均值，但样本数据是非正态的。那么置信区间覆盖均值的概率不一定等于0.95。使用蒙特卡罗实验估计样本容量<span class="math inline">\(n=20\)</span>的<span class="math inline">\(\chi^2(2)\)</span>数据随机样本的t区间覆盖概率。将t区间结果与例6.4中的模拟结果进行比较。</p>
<p><em>思路：</em> 先生成20个服从<span class="math inline">\(\chi^2(2)\)</span>的随机数，计算样本的t检验的置信区间，然后统计一下包含真实均值的区间数量，除以1000即要求解的t区间覆盖概率。</p>
<p><em>解：</em>
我们将计算区间的方法写在函数<code>CI</code>中，并用<code>replicate</code>函数重复1000次计算。代码及结果如下：</p>
<div class="sourceCode" id="cb42"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb42-1"><a href="#cb42-1" tabindex="-1"></a>n <span class="ot">=</span> <span class="dv">20</span></span>
<span id="cb42-2"><a href="#cb42-2" tabindex="-1"></a>m <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb42-3"><a href="#cb42-3" tabindex="-1"></a>alpha <span class="ot">=</span> <span class="fl">0.05</span></span>
<span id="cb42-4"><a href="#cb42-4" tabindex="-1"></a></span>
<span id="cb42-5"><a href="#cb42-5" tabindex="-1"></a>CI <span class="ot">=</span> <span class="cf">function</span>(n, alpha) {</span>
<span id="cb42-6"><a href="#cb42-6" tabindex="-1"></a>  x <span class="ot">=</span> <span class="fu">rchisq</span>(n, <span class="dv">2</span>)</span>
<span id="cb42-7"><a href="#cb42-7" tabindex="-1"></a>  upCL <span class="ot">=</span> <span class="fu">mean</span>(x) <span class="sc">+</span> <span class="fu">sqrt</span>(<span class="fu">var</span>(x)<span class="sc">/</span>n) <span class="sc">*</span> <span class="fu">qt</span>(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>, n<span class="dv">-1</span>)</span>
<span id="cb42-8"><a href="#cb42-8" tabindex="-1"></a>  lowCL <span class="ot">=</span> <span class="fu">mean</span>(x) <span class="sc">-</span> <span class="fu">sqrt</span>(<span class="fu">var</span>(x)<span class="sc">/</span>n) <span class="sc">*</span> <span class="fu">qt</span>(<span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>, n<span class="dv">-1</span>)</span>
<span id="cb42-9"><a href="#cb42-9" tabindex="-1"></a>  CL <span class="ot">=</span> <span class="fu">c</span>(upCL, lowCL)</span>
<span id="cb42-10"><a href="#cb42-10" tabindex="-1"></a>  <span class="fu">return</span> (CL)</span>
<span id="cb42-11"><a href="#cb42-11" tabindex="-1"></a>}</span>
<span id="cb42-12"><a href="#cb42-12" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">123</span>)</span>
<span id="cb42-13"><a href="#cb42-13" tabindex="-1"></a>myCI <span class="ot">=</span> <span class="fu">replicate</span>(m, <span class="at">expr =</span> <span class="fu">CI</span>(n, alpha))</span>
<span id="cb42-14"><a href="#cb42-14" tabindex="-1"></a></span>
<span id="cb42-15"><a href="#cb42-15" tabindex="-1"></a>prob <span class="ot">=</span> (<span class="fu">mean</span>(myCI[<span class="dv">1</span>,]<span class="sc">&lt;</span><span class="dv">2</span>)<span class="sc">+</span><span class="fu">mean</span>(myCI[<span class="dv">2</span>,]<span class="sc">&gt;</span><span class="dv">2</span>))</span>
<span id="cb42-16"><a href="#cb42-16" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&#39;随机样本的t区间覆盖概率为：&#39;</span>, <span class="dv">1</span><span class="sc">-</span>prob)</span></code></pre></div>
<pre><code>## 随机样本的t区间覆盖概率为： 0.908</code></pre>
<p>当样本数据是非正态的时候，随机样本的t区间覆盖概率不再是<span class="math inline">\(1-\alpha\)</span>，而是略小一些的值，在本题中是0.908。</p>
<p>而在Example 6.4中，当样本数据是正态的时候，方差区间覆盖概率接近<span class="math inline">\(1-\alpha\)</span>，为0.956；当样本数据是非正态的时候，方差区间覆盖概率远小于<span class="math inline">\(1-\alpha\)</span>，为0.773。这也说明了，对于偏离正态数据，t区间应该比方差的区间更稳健。</p>
</div>
<div id="第六题" class="section level2">
<h2>第六题</h2>
<p><em>问题描述：</em>
当抽样总体是非正态时，利用蒙特卡罗模拟研究t检验的经验1型错误率是否近似等于名义显著性水平<span class="math inline">\(\alpha\)</span>。t检验对于轻微偏离正态是稳健的。讨论抽样总体为(i)
<span class="math inline">\(\chi^2(1)\)</span>、(ii) Uniform(0,2)和(iii)
Exponential(1)的情况下的模拟结果。在每种情况下，检验<span class="math inline">\(H_0:\mu =\mu_0~vs~H_1:
\mu\neq\mu_0\)</span>，其中<span class="math inline">\(\mu_0\)</span>分别为<span class="math inline">\(\chi^2(1)\)</span>、Uniform(0,2)和Exponential(1)的均值。</p>
<p><em>思路：</em>
每一个小题的思路都是类似的，生成n个服从某抽样总体分布的随机数，计算样本的t检验的P值（并据此做假设检验）及经验1型错误率。</p>
<p><em>解：</em> 注意到<span class="math inline">\(\chi^2(1)\)</span>、Uniform(0,2)和Exponential(1)的均值为1，因此在假设检验问题中，<span class="math inline">\(\mu_0=1\)</span>。进行1000次试验，令<span class="math inline">\(\alpha=0.05\)</span>，计算P值的均值以及经验1型错误率（P值小于名义显著性水平<span class="math inline">\(\alpha\)</span>的概率）。代码及结果如下：</p>
<div class="sourceCode" id="cb44"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb44-1"><a href="#cb44-1" tabindex="-1"></a>m <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb44-2"><a href="#cb44-2" tabindex="-1"></a>alpha <span class="ot">=</span> <span class="fl">0.05</span></span>
<span id="cb44-3"><a href="#cb44-3" tabindex="-1"></a>mu0 <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb44-4"><a href="#cb44-4" tabindex="-1"></a>n <span class="ot">=</span> <span class="dv">20</span></span>
<span id="cb44-5"><a href="#cb44-5" tabindex="-1"></a>p <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="dv">3</span>, m)</span>
<span id="cb44-6"><a href="#cb44-6" tabindex="-1"></a>p.hat <span class="ot">=</span> error <span class="ot">=</span> <span class="fu">numeric</span>(<span class="dv">3</span>)</span>
<span id="cb44-7"><a href="#cb44-7" tabindex="-1"></a></span>
<span id="cb44-8"><a href="#cb44-8" tabindex="-1"></a><span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>m) {</span>
<span id="cb44-9"><a href="#cb44-9" tabindex="-1"></a>  <span class="fu">set.seed</span>(j)</span>
<span id="cb44-10"><a href="#cb44-10" tabindex="-1"></a>  ttest1 <span class="ot">=</span> <span class="fu">t.test</span>(<span class="fu">rchisq</span>(n, <span class="dv">1</span>), <span class="at">mu =</span> mu0)</span>
<span id="cb44-11"><a href="#cb44-11" tabindex="-1"></a>  ttest2 <span class="ot">=</span> <span class="fu">t.test</span>(<span class="fu">runif</span>(n, <span class="dv">0</span>, <span class="dv">2</span>), <span class="at">mu =</span> mu0)</span>
<span id="cb44-12"><a href="#cb44-12" tabindex="-1"></a>  ttest3 <span class="ot">=</span> <span class="fu">t.test</span>(<span class="fu">rexp</span>(n, <span class="dv">1</span>), <span class="at">mu =</span> mu0)</span>
<span id="cb44-13"><a href="#cb44-13" tabindex="-1"></a>  p[<span class="dv">1</span>, j] <span class="ot">=</span> ttest1<span class="sc">$</span>p.value</span>
<span id="cb44-14"><a href="#cb44-14" tabindex="-1"></a>  p[<span class="dv">2</span>, j] <span class="ot">=</span> ttest2<span class="sc">$</span>p.value</span>
<span id="cb44-15"><a href="#cb44-15" tabindex="-1"></a>  p[<span class="dv">3</span>, j] <span class="ot">=</span> ttest3<span class="sc">$</span>p.value</span>
<span id="cb44-16"><a href="#cb44-16" tabindex="-1"></a>}</span>
<span id="cb44-17"><a href="#cb44-17" tabindex="-1"></a></span>
<span id="cb44-18"><a href="#cb44-18" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>) {</span>
<span id="cb44-19"><a href="#cb44-19" tabindex="-1"></a>  p.hat[i] <span class="ot">=</span> <span class="fu">mean</span>(p[i,])</span>
<span id="cb44-20"><a href="#cb44-20" tabindex="-1"></a>  error[i] <span class="ot">=</span> <span class="fu">mean</span>(p[i,]<span class="sc">&lt;</span>alpha)</span>
<span id="cb44-21"><a href="#cb44-21" tabindex="-1"></a>}</span>
<span id="cb44-22"><a href="#cb44-22" tabindex="-1"></a>p.hat</span></code></pre></div>
<pre><code>## [1] 0.4804856 0.4991935 0.4813325</code></pre>
<div class="sourceCode" id="cb46"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb46-1"><a href="#cb46-1" tabindex="-1"></a>error</span></code></pre></div>
<pre><code>## [1] 0.084 0.058 0.080</code></pre>
<p>由P值的均值大于显著性水平，我们没有充足的理由拒绝<span class="math inline">\(H_0: \mu =
\mu_0\)</span>，因此认为三个非正态抽样总体的均值为1。但经验1型错误率并不近似等于名义显著性水平<span class="math inline">\(\alpha\)</span>，均大于<span class="math inline">\(\alpha\)</span>。</p>
</div>
</div>
<div id="hw4" class="section level1">
<h1>HW4</h1>
<div id="第一题-3" class="section level2">
<h2>第一题</h2>
<p><em>问题描述：</em>
考虑m=1000个假设，其中前95%个原假设成立，后5%个对立假设成立。在原假设之下，P值服从U(0,1)分布，在对立假设之下，P值服从Beta(0.1,1)分布（可用rbeta生成随机数）。基于<code>p.adjust</code>，应用Bonferroni校正与BH校正生成的m个独立的P值，从而得到校正后的P值，与<span class="math inline">\(\alpha=0.1\)</span>比较确定是否拒绝原假设。基于M=1000次模拟，估计FWER、FDR、TPR，输出一个表格。</p>
<p><em>思路：</em>在每一次模拟中，先按照不同假设下P值的分布生成m个P值，分别用两种校正方法计算校正后的P值，然后决定是否拒绝原假设。基于这一结果，再估计FWER、FDR、TPR。</p>
<p><em>解：</em>
首先进行M=1000次模拟，在每一次模拟中，生成950个服从U(0,1)分布的随机数作为原假设成立下的P值，50个服从Beta(0,1)分布的随机数作为对立假设成立下的P值。分别用Bonferroni校正与BH校正得到校正后的1000个独立的P值，与<span class="math inline">\(\alpha=0.1\)</span>比较，判断是否拒绝原假设。</p>
<p>FWER的计算方法为： <span class="math display">\[FWER =
P(\mbox{当}H_0\mbox{为真时，至少拒绝1个}H_0),\]</span></p>
<p>FDR的计算方法为： <span class="math display">\[FDR =
\dfrac{FP}{FP+TP} =
\dfrac{\mbox{拒绝的}H_0\mbox{的数量}|H_0\mbox{为真}}{\mbox{拒绝的}H_0\mbox{的数量}|H_0\mbox{为真}+\mbox{拒绝的}H_0\mbox{的数量}|H_1\mbox{为真}},\]</span></p>
<p>TPR的计算方法为（准确来说，“拒绝的<span class="math inline">\(H_1\)</span>的数量”应当是“没有充分理由拒绝的<span class="math inline">\(H_0\)</span>的数量”）： <span class="math display">\[TPR = \dfrac{TP}{TP+FN} =
\dfrac{\mbox{拒绝的}H_0\mbox{的数量}|H_1\mbox{为真}}{\mbox{拒绝的}H_0\mbox{的数量}|H_1\mbox{为真}+\mbox{拒绝的}H_1\mbox{的数量}|H_1\mbox{为真}},\]</span></p>
<p>以下是实现该流程的代码：</p>
<div class="sourceCode" id="cb48"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb48-1"><a href="#cb48-1" tabindex="-1"></a>M <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb48-2"><a href="#cb48-2" tabindex="-1"></a>m <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb48-3"><a href="#cb48-3" tabindex="-1"></a>alpha <span class="ot">=</span> <span class="fl">0.1</span></span>
<span id="cb48-4"><a href="#cb48-4" tabindex="-1"></a></span>
<span id="cb48-5"><a href="#cb48-5" tabindex="-1"></a>p_Bonf <span class="ot">=</span> p_BH <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, M, m)</span>
<span id="cb48-6"><a href="#cb48-6" tabindex="-1"></a>value_Bonf <span class="ot">=</span> value_BH <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, M, <span class="dv">3</span>)</span>
<span id="cb48-7"><a href="#cb48-7" tabindex="-1"></a></span>
<span id="cb48-8"><a href="#cb48-8" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>M) {</span>
<span id="cb48-9"><a href="#cb48-9" tabindex="-1"></a>  <span class="fu">set.seed</span>(i)</span>
<span id="cb48-10"><a href="#cb48-10" tabindex="-1"></a>  p_H0 <span class="ot">=</span> <span class="fu">runif</span>(<span class="fl">0.95</span><span class="sc">*</span>m, <span class="dv">0</span>, <span class="dv">1</span>)</span>
<span id="cb48-11"><a href="#cb48-11" tabindex="-1"></a>  p_H1 <span class="ot">=</span> <span class="fu">rbeta</span>(<span class="fl">0.05</span><span class="sc">*</span>m, <span class="at">shape1 =</span> <span class="fl">0.1</span>, <span class="at">shape2 =</span> <span class="dv">1</span>)</span>
<span id="cb48-12"><a href="#cb48-12" tabindex="-1"></a>  p <span class="ot">=</span> <span class="fu">c</span>(p_H0, p_H1)</span>
<span id="cb48-13"><a href="#cb48-13" tabindex="-1"></a>  p_Bonf[i,] <span class="ot">=</span> <span class="fu">p.adjust</span>(p, <span class="at">method =</span> <span class="st">&#39;bonferroni&#39;</span>)</span>
<span id="cb48-14"><a href="#cb48-14" tabindex="-1"></a>  p_BH[i,] <span class="ot">=</span> <span class="fu">p.adjust</span>(p, <span class="at">method =</span> <span class="st">&#39;BH&#39;</span>)</span>
<span id="cb48-15"><a href="#cb48-15" tabindex="-1"></a>  <span class="co"># FWER</span></span>
<span id="cb48-16"><a href="#cb48-16" tabindex="-1"></a>  value_Bonf[i, <span class="dv">1</span>] <span class="ot">=</span> <span class="fu">any</span>(p_Bonf[i,<span class="dv">1</span><span class="sc">:</span><span class="dv">950</span>] <span class="sc">&lt;</span> alpha)</span>
<span id="cb48-17"><a href="#cb48-17" tabindex="-1"></a>  value_BH[i, <span class="dv">1</span>] <span class="ot">=</span> <span class="fu">any</span>(p_BH[i,<span class="dv">1</span><span class="sc">:</span><span class="dv">950</span>] <span class="sc">&lt;</span> alpha)</span>
<span id="cb48-18"><a href="#cb48-18" tabindex="-1"></a>  <span class="co"># FDR</span></span>
<span id="cb48-19"><a href="#cb48-19" tabindex="-1"></a>  value_Bonf[i, <span class="dv">2</span>] <span class="ot">=</span> <span class="fu">sum</span>(p_Bonf[i, <span class="dv">1</span><span class="sc">:</span><span class="dv">950</span>] <span class="sc">&lt;</span> alpha) <span class="sc">/</span> </span>
<span id="cb48-20"><a href="#cb48-20" tabindex="-1"></a>    (<span class="fu">sum</span>(p_Bonf[i, <span class="dv">1</span><span class="sc">:</span><span class="dv">950</span>] <span class="sc">&lt;</span> alpha) <span class="sc">+</span> <span class="fu">sum</span>(p_Bonf[i, <span class="dv">951</span><span class="sc">:</span><span class="dv">1000</span>] <span class="sc">&lt;</span> alpha))</span>
<span id="cb48-21"><a href="#cb48-21" tabindex="-1"></a>  value_BH[i, <span class="dv">2</span>] <span class="ot">=</span> <span class="fu">sum</span>(p_BH[i, <span class="dv">1</span><span class="sc">:</span><span class="dv">950</span>] <span class="sc">&lt;</span> alpha) <span class="sc">/</span> </span>
<span id="cb48-22"><a href="#cb48-22" tabindex="-1"></a>    (<span class="fu">sum</span>(p_BH[i, <span class="dv">1</span><span class="sc">:</span><span class="dv">950</span>] <span class="sc">&lt;</span> alpha) <span class="sc">+</span> <span class="fu">sum</span>(p_BH[i, <span class="dv">951</span><span class="sc">:</span><span class="dv">1000</span>] <span class="sc">&lt;</span> alpha))</span>
<span id="cb48-23"><a href="#cb48-23" tabindex="-1"></a>  <span class="co"># TPR</span></span>
<span id="cb48-24"><a href="#cb48-24" tabindex="-1"></a>  value_Bonf[i, <span class="dv">3</span>] <span class="ot">=</span> <span class="fu">sum</span>(p_Bonf[i, <span class="dv">951</span><span class="sc">:</span><span class="dv">1000</span>] <span class="sc">&lt;</span> alpha) <span class="sc">/</span> </span>
<span id="cb48-25"><a href="#cb48-25" tabindex="-1"></a>    (<span class="fu">sum</span>(p_Bonf[i, <span class="dv">951</span><span class="sc">:</span><span class="dv">1000</span>] <span class="sc">&lt;</span> alpha) <span class="sc">+</span> <span class="fu">sum</span>(p_Bonf[i, <span class="dv">951</span><span class="sc">:</span><span class="dv">1000</span>] <span class="sc">&gt;=</span> alpha))</span>
<span id="cb48-26"><a href="#cb48-26" tabindex="-1"></a>  value_BH[i, <span class="dv">3</span>] <span class="ot">=</span> <span class="fu">sum</span>(p_BH[i, <span class="dv">951</span><span class="sc">:</span><span class="dv">1000</span>] <span class="sc">&lt;</span> alpha) <span class="sc">/</span> </span>
<span id="cb48-27"><a href="#cb48-27" tabindex="-1"></a>    (<span class="fu">sum</span>(p_BH[i, <span class="dv">951</span><span class="sc">:</span><span class="dv">1000</span>] <span class="sc">&lt;</span> alpha) <span class="sc">+</span> <span class="fu">sum</span>(p_BH[i, <span class="dv">951</span><span class="sc">:</span><span class="dv">1000</span>] <span class="sc">&gt;=</span> alpha))</span>
<span id="cb48-28"><a href="#cb48-28" tabindex="-1"></a>}</span></code></pre></div>
<p>最后，我们将结果输出成表格：</p>
<div class="sourceCode" id="cb49"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb49-1"><a href="#cb49-1" tabindex="-1"></a>value <span class="ot">=</span> <span class="fu">rbind</span>(<span class="fu">colMeans</span>(value_Bonf), <span class="fu">colMeans</span>(value_BH))</span>
<span id="cb49-2"><a href="#cb49-2" tabindex="-1"></a><span class="fu">colnames</span>(value) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">&#39;FWER&#39;</span>, <span class="st">&#39;FDR&#39;</span>, <span class="st">&#39;TPR&#39;</span>)</span>
<span id="cb49-3"><a href="#cb49-3" tabindex="-1"></a><span class="fu">rownames</span>(value) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">&#39;Bonferroni&#39;</span>, <span class="st">&#39;B-H&#39;</span>)</span>
<span id="cb49-4"><a href="#cb49-4" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(<span class="fu">round</span>(value, <span class="dv">3</span>), <span class="at">format =</span> <span class="st">&quot;latex&quot;</span>,<span class="at">align=</span><span class="st">&#39;c&#39;</span>)</span></code></pre></div>
<p>从结果可以看出，当<span class="math inline">\(\alpha=0.1\)</span>时，Bonferroni校正的P值计算出的FWER约为0.1，但FDR远小于0.1。BH校正的P值计算出的FWER远大于0.1，FDR约为0.1。而且Bonferroni校正的P值计算出的TPR小于B-H校正的P值计算出的TPR。</p>
</div>
<div id="第二题-3" class="section level2">
<h2>第二题</h2>
<p><em>问题描述：</em> 假设<span class="math inline">\(X\sim
Exp(\lambda)\)</span>，则<span class="math inline">\(\lambda\)</span>的MLE为<span class="math inline">\(\hat{\lambda}=1/\bar
X\)</span>。这并不是一个无偏估计，<span class="math inline">\(E\hat{\lambda} = n\lambda/(n-1)\)</span>，<span class="math inline">\(sd(\hat{\lambda}) =
n\lambda/[(n-1)\sqrt{n-2}]\)</span>。参数要求如下：</p>
<ul>
<li><p>真实值<span class="math inline">\(\lambda = 2\)</span>，</p></li>
<li><p>样本量<span class="math inline">\(n = 5, 10,
20\)</span>，</p></li>
<li><p>Bootstrap的重复次数<span class="math inline">\(B=1000\)</span>，</p></li>
<li><p>模拟的重复次数<span class="math inline">\(m=1000\)</span>，</p></li>
</ul>
<p>比较mean bootstrap bias，bootstrap standard
error与理论值，将结果输出成一个表格。</p>
<p><em>思路：</em> 首先生成n个<span class="math inline">\(Exp(2)\)</span>的随机数，按照参数的估计式，在每一次模拟中，重复B次Bootstrap，计算Bootstrap
estimates of bias and standard
error。最后计算estimates的均值，与理论值比较。</p>
<p><em>解：</em>
编写一个函数，输入为样本量n，进行1000次模拟，每次模拟进行1000次Bootstrap，输出Bootstrap
estimates与理论值。代码如下：</p>
<div class="sourceCode" id="cb50"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb50-1"><a href="#cb50-1" tabindex="-1"></a>lambda_bootstrap <span class="ot">=</span> <span class="cf">function</span>(n){</span>
<span id="cb50-2"><a href="#cb50-2" tabindex="-1"></a>  <span class="co"># 理论值</span></span>
<span id="cb50-3"><a href="#cb50-3" tabindex="-1"></a>  bias_the <span class="ot">=</span> <span class="dv">2</span><span class="sc">*</span>n<span class="sc">/</span>(n<span class="dv">-1</span>) <span class="sc">-</span> <span class="dv">2</span></span>
<span id="cb50-4"><a href="#cb50-4" tabindex="-1"></a>  sd_the <span class="ot">=</span> <span class="dv">2</span><span class="sc">*</span>n<span class="sc">/</span>((n<span class="dv">-1</span>)<span class="sc">*</span><span class="fu">sqrt</span>(n<span class="dv">-2</span>))</span>
<span id="cb50-5"><a href="#cb50-5" tabindex="-1"></a>  </span>
<span id="cb50-6"><a href="#cb50-6" tabindex="-1"></a>  m <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb50-7"><a href="#cb50-7" tabindex="-1"></a>  B <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb50-8"><a href="#cb50-8" tabindex="-1"></a>  bias <span class="ot">=</span> sd <span class="ot">=</span> <span class="fu">numeric</span>(m)</span>
<span id="cb50-9"><a href="#cb50-9" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>m) {</span>
<span id="cb50-10"><a href="#cb50-10" tabindex="-1"></a>    x <span class="ot">=</span> <span class="fu">rexp</span>(n, <span class="dv">2</span>)</span>
<span id="cb50-11"><a href="#cb50-11" tabindex="-1"></a>    <span class="fu">set.seed</span>(i)</span>
<span id="cb50-12"><a href="#cb50-12" tabindex="-1"></a>    lambda_star <span class="ot">=</span> <span class="fu">numeric</span>(B)</span>
<span id="cb50-13"><a href="#cb50-13" tabindex="-1"></a>    <span class="co"># 采样值</span></span>
<span id="cb50-14"><a href="#cb50-14" tabindex="-1"></a>    <span class="cf">for</span> (b <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>B) {</span>
<span id="cb50-15"><a href="#cb50-15" tabindex="-1"></a>      xstar <span class="ot">=</span> <span class="fu">sample</span>(x, <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb50-16"><a href="#cb50-16" tabindex="-1"></a>      lambda_star[b] <span class="ot">=</span> <span class="dv">1</span> <span class="sc">/</span> <span class="fu">mean</span>(xstar)</span>
<span id="cb50-17"><a href="#cb50-17" tabindex="-1"></a>    }</span>
<span id="cb50-18"><a href="#cb50-18" tabindex="-1"></a>    bias[i] <span class="ot">=</span> <span class="fu">mean</span>(lambda_star) <span class="sc">-</span> <span class="dv">1</span> <span class="sc">/</span> <span class="fu">mean</span>(x)</span>
<span id="cb50-19"><a href="#cb50-19" tabindex="-1"></a>    sd[i] <span class="ot">=</span> <span class="fu">sd</span>(lambda_star)</span>
<span id="cb50-20"><a href="#cb50-20" tabindex="-1"></a>  }</span>
<span id="cb50-21"><a href="#cb50-21" tabindex="-1"></a>  value <span class="ot">=</span> <span class="fu">c</span>(<span class="fu">mean</span>(bias), bias_the, <span class="fu">mean</span>(sd), sd_the)</span>
<span id="cb50-22"><a href="#cb50-22" tabindex="-1"></a>  <span class="fu">return</span>(value)</span>
<span id="cb50-23"><a href="#cb50-23" tabindex="-1"></a>}</span></code></pre></div>
<p>分别计算样本量<span class="math inline">\(n = 5, 10,
20\)</span>时的mean bootstrap bias，bootstrap standard
error与相应的理论值：</p>
<div class="sourceCode" id="cb51"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb51-1"><a href="#cb51-1" tabindex="-1"></a>value <span class="ot">=</span> <span class="fu">rbind</span>(<span class="fu">lambda_bootstrap</span>(<span class="dv">5</span>),<span class="fu">lambda_bootstrap</span>(<span class="dv">10</span>),<span class="fu">lambda_bootstrap</span>(<span class="dv">20</span>))</span>
<span id="cb51-2"><a href="#cb51-2" tabindex="-1"></a><span class="fu">colnames</span>(value) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">&#39;Bias-bootstrap&#39;</span>, <span class="st">&#39;Bias-theory&#39;</span>, <span class="st">&#39;Sd-bootstrap&#39;</span>, <span class="st">&#39;Sd-theory&#39;</span>)</span>
<span id="cb51-3"><a href="#cb51-3" tabindex="-1"></a><span class="fu">rownames</span>(value) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">&#39;n=5&#39;</span>, <span class="st">&#39;n=10&#39;</span>, <span class="st">&#39;n=20&#39;</span>)</span>
<span id="cb51-4"><a href="#cb51-4" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(<span class="fu">round</span>(value, <span class="dv">3</span>), <span class="at">format =</span> <span class="st">&quot;latex&quot;</span>,<span class="at">align=</span><span class="st">&#39;c&#39;</span>)</span></code></pre></div>
<p>从结果可以看出，虽然n较小（n=5）时，bootstrap方法计算的结果与理论值有较大差别，但随着n变大，偏差的bootstrap值与标准差的bootstrap值逐渐接近理论值。</p>
</div>
<div id="第三题-3" class="section level2">
<h2>第三题</h2>
<p><em>问题描述：</em> 计算例7.2 correlation
statistic的t置信区间的bootstrap估计.</p>
<p><em>思路：</em>
进行B次bootstrap，每一次中都基于采样得到的样本计算correlation
statistic，并且进行R次bootstrap来计算统计量的标准差。在实际编程中，可以将correlation
statistic的计算编写成一个函数方便调用。</p>
<p><em>解：</em> 假设<span class="math inline">\(x =
(x_1,...x_n)\)</span>是观测到的样本，则<span class="math inline">\(100(1-\alpha)\%\)</span>bootstrap t confidence
interval是： <span class="math display">\[(\hat{\theta}-t^*_{1-\alpha/2}\hat{se}(\hat{\theta}),~
\hat{\theta}-t^*_{\alpha/2}\hat{se}(\hat{\theta})),\]</span> 其中，<span class="math inline">\(\hat{\theta}\)</span>是基于观测样本直接计算出的correlation
statistic，<span class="math inline">\(\hat{se}(\hat{\theta})\)</span>
是<span class="math inline">\(\hat{\theta}\)</span>的标准差估计值。在第<span class="math inline">\(b\)</span>次bootstrap中，记<span class="math inline">\(t^{(b)}=\dfrac{\hat{\theta}^{(b)}-\hat{\theta}}{\hat{se}(\hat{\theta}^{(b)})}\)</span>，其中<span class="math inline">\(\hat{se}(\hat{\theta}^{(b)})\)</span>是再次用bootstrap方法，从当前bootstrap样本<span class="math inline">\(x^{(b)}\)</span>中重采样得到的估计值，则<span class="math inline">\(t^*_{1-\alpha/2}\)</span>与<span class="math inline">\(t^*_{\alpha/2}\)</span>为<span class="math inline">\(t^{(1)},...,t^{(B)}\)</span>的分位数。</p>
<p>首先将计算correlation
statistic的方法编写成函数<code>correlation</code>：</p>
<div class="sourceCode" id="cb52"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb52-1"><a href="#cb52-1" tabindex="-1"></a>correlation <span class="ot">=</span> <span class="cf">function</span>(data){</span>
<span id="cb52-2"><a href="#cb52-2" tabindex="-1"></a>  <span class="fu">cor</span>(data[,<span class="dv">1</span>],data[,<span class="dv">2</span>])</span>
<span id="cb52-3"><a href="#cb52-3" tabindex="-1"></a>}</span></code></pre></div>
<p>接着，我们将计算t置信区间的方法编写成函数<code>Boot.t.CI</code>。在输入的参数中，总bootstrap次数B的默认值为500，为估计<span class="math inline">\(\hat{se}(\hat{\theta})\)</span>的bootstrap次数R的默认值为100，置信水平level的默认值为0.95，statistic为指定的统计量计算方法：</p>
<div class="sourceCode" id="cb53"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb53-1"><a href="#cb53-1" tabindex="-1"></a>Boot.t.CI <span class="ot">=</span> <span class="cf">function</span>(x, <span class="at">B =</span> <span class="dv">500</span>, <span class="at">R =</span> <span class="dv">100</span>, <span class="at">level =</span> <span class="fl">0.95</span>, statistic){</span>
<span id="cb53-2"><a href="#cb53-2" tabindex="-1"></a>  <span class="co"># 初始化</span></span>
<span id="cb53-3"><a href="#cb53-3" tabindex="-1"></a>  x <span class="ot">=</span> <span class="fu">as.matrix</span>(x)</span>
<span id="cb53-4"><a href="#cb53-4" tabindex="-1"></a>  n <span class="ot">=</span> <span class="fu">nrow</span>(x)</span>
<span id="cb53-5"><a href="#cb53-5" tabindex="-1"></a>  stat <span class="ot">=</span> <span class="fu">numeric</span>(B)</span>
<span id="cb53-6"><a href="#cb53-6" tabindex="-1"></a>  se <span class="ot">=</span> <span class="fu">numeric</span>(B)</span>
<span id="cb53-7"><a href="#cb53-7" tabindex="-1"></a>  alpha <span class="ot">=</span> <span class="dv">1</span> <span class="sc">-</span> level</span>
<span id="cb53-8"><a href="#cb53-8" tabindex="-1"></a>  </span>
<span id="cb53-9"><a href="#cb53-9" tabindex="-1"></a>  <span class="co"># estimate of standard error</span></span>
<span id="cb53-10"><a href="#cb53-10" tabindex="-1"></a>  boot.se <span class="ot">&lt;-</span> <span class="cf">function</span>(x, R, f) {</span>
<span id="cb53-11"><a href="#cb53-11" tabindex="-1"></a>    <span class="co"># 初始化</span></span>
<span id="cb53-12"><a href="#cb53-12" tabindex="-1"></a>    x <span class="ot">=</span> <span class="fu">as.matrix</span>(x)</span>
<span id="cb53-13"><a href="#cb53-13" tabindex="-1"></a>    m <span class="ot">=</span> <span class="fu">nrow</span>(x)</span>
<span id="cb53-14"><a href="#cb53-14" tabindex="-1"></a>    <span class="co"># 计算hat theta并返回sd</span></span>
<span id="cb53-15"><a href="#cb53-15" tabindex="-1"></a>    theta <span class="ot">=</span> <span class="fu">replicate</span>(R, <span class="at">expr =</span> {</span>
<span id="cb53-16"><a href="#cb53-16" tabindex="-1"></a>      i <span class="ot">=</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span>m, <span class="at">size =</span> m, <span class="at">replace =</span> <span class="cn">TRUE</span>) </span>
<span id="cb53-17"><a href="#cb53-17" tabindex="-1"></a>      <span class="fu">f</span>(x[i, ])</span>
<span id="cb53-18"><a href="#cb53-18" tabindex="-1"></a>      })</span>
<span id="cb53-19"><a href="#cb53-19" tabindex="-1"></a>    <span class="fu">return</span>(<span class="fu">sd</span>(theta))</span>
<span id="cb53-20"><a href="#cb53-20" tabindex="-1"></a>  }</span>
<span id="cb53-21"><a href="#cb53-21" tabindex="-1"></a>  </span>
<span id="cb53-22"><a href="#cb53-22" tabindex="-1"></a>  <span class="co"># B times bootstrap</span></span>
<span id="cb53-23"><a href="#cb53-23" tabindex="-1"></a>  <span class="cf">for</span> (b <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>B) {</span>
<span id="cb53-24"><a href="#cb53-24" tabindex="-1"></a>    j <span class="ot">=</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span>n, <span class="at">size =</span> n, <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb53-25"><a href="#cb53-25" tabindex="-1"></a>    y <span class="ot">=</span> x[j, ]</span>
<span id="cb53-26"><a href="#cb53-26" tabindex="-1"></a>    stat[b] <span class="ot">=</span> <span class="fu">statistic</span>(y)</span>
<span id="cb53-27"><a href="#cb53-27" tabindex="-1"></a>    se[b] <span class="ot">=</span> <span class="fu">boot.se</span>(y, <span class="at">R =</span> R, <span class="at">f =</span> statistic)</span>
<span id="cb53-28"><a href="#cb53-28" tabindex="-1"></a>  }</span>
<span id="cb53-29"><a href="#cb53-29" tabindex="-1"></a>  </span>
<span id="cb53-30"><a href="#cb53-30" tabindex="-1"></a>  <span class="co"># CI</span></span>
<span id="cb53-31"><a href="#cb53-31" tabindex="-1"></a>  stat0 <span class="ot">=</span> <span class="fu">statistic</span>(x)</span>
<span id="cb53-32"><a href="#cb53-32" tabindex="-1"></a>  t <span class="ot">=</span> (stat <span class="sc">-</span> stat0) <span class="sc">/</span> se</span>
<span id="cb53-33"><a href="#cb53-33" tabindex="-1"></a>  se0 <span class="ot">=</span> <span class="fu">sd</span>(stat)</span>
<span id="cb53-34"><a href="#cb53-34" tabindex="-1"></a>  tstar <span class="ot">=</span> <span class="fu">quantile</span>(t, <span class="fu">c</span>(alpha<span class="sc">/</span><span class="dv">2</span>, <span class="dv">1</span><span class="sc">-</span>alpha<span class="sc">/</span><span class="dv">2</span>), <span class="at">type =</span> <span class="dv">1</span>)</span>
<span id="cb53-35"><a href="#cb53-35" tabindex="-1"></a>  <span class="fu">names</span>(tstar) <span class="ot">=</span> <span class="fu">rev</span>(<span class="fu">names</span>(tstar))</span>
<span id="cb53-36"><a href="#cb53-36" tabindex="-1"></a>  CI <span class="ot">=</span> <span class="fu">rev</span>(stat0 <span class="sc">-</span> tstar <span class="sc">*</span> se0)</span>
<span id="cb53-37"><a href="#cb53-37" tabindex="-1"></a>}</span></code></pre></div>
<p>最后，我们调用<code>Boot.t.CI</code>与<code>correlation</code>函数，计算correlation
statistic的95%t置信区间的bootstrap估计。指定B=2000，R=200.</p>
<div class="sourceCode" id="cb54"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb54-1"><a href="#cb54-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">5</span>)</span>
<span id="cb54-2"><a href="#cb54-2" tabindex="-1"></a>data <span class="ot">=</span> <span class="fu">cbind</span>(law<span class="sc">$</span>LSAT,law<span class="sc">$</span>GPA)</span>
<span id="cb54-3"><a href="#cb54-3" tabindex="-1"></a>corCI <span class="ot">=</span> <span class="fu">Boot.t.CI</span>(data, <span class="at">statistic =</span> correlation, <span class="at">B=</span><span class="dv">2000</span>, <span class="at">R=</span><span class="dv">200</span>)</span>
<span id="cb54-4"><a href="#cb54-4" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&#39;correlation statistic的95%t置信区间是：&#39;</span>, corCI)</span></code></pre></div>
<pre><code>## correlation statistic的95%t置信区间是： -0.259984 0.9682271</code></pre>
<p>而根据样本直接计算出的相关系数为0.7763745，可以看出本题计算的95%t置信区间的bootstrap估计包含了样本相关系数。</p>
</div>
</div>
<div id="hw5" class="section level1">
<h1>HW5</h1>
<div id="第一题-4" class="section level2">
<h2>第一题</h2>
<p><em>问题描述：</em>根据习题7.4，分别用standard normal, basic,
percentile, and BCa四种方法，计算the mean time between failures（即<span class="math inline">\(1/\lambda\)</span>）的95% bootstrap confidence
intervals。比较这些区间，并解释它们为什么不同。</p>
<p><em>思路：</em>由习题7.4可知<span class="math inline">\(\lambda\)</span>的MLE估计，从而可以用样本数据计算<span class="math inline">\(1/\lambda\)</span>的估计量，代入到置信区间的公式中得到结果。</p>
<p><em>解：</em> 由于数据服从<span class="math inline">\(Exp(\lambda)\)</span>，<span class="math inline">\(\lambda\)</span>的MLE估计为： <span class="math display">\[\hat\lambda =
\dfrac{n}{\sum_{i=1}^n}x_i=\dfrac{1}{\bar x},\]</span> 因此，<span class="math inline">\(1/\lambda\)</span>的MLE估计为： <span class="math display">\[\dfrac{1}{\hat\lambda}=\bar x.\]</span></p>
<p>我们分别用<code>boot</code>中自带的<code>boot.ci()</code>函数以及自己编写的函数计算四个置信区间。</p>
<p>（1）<code>boot.ci()</code>函数的R代码及结果如下：</p>
<div class="sourceCode" id="cb56"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb56-1"><a href="#cb56-1" tabindex="-1"></a><span class="co"># 导入数据</span></span>
<span id="cb56-2"><a href="#cb56-2" tabindex="-1"></a><span class="fu">library</span>(boot)</span>
<span id="cb56-3"><a href="#cb56-3" tabindex="-1"></a>data <span class="ot">=</span> aircondit</span>
<span id="cb56-4"><a href="#cb56-4" tabindex="-1"></a>lam.hat <span class="ot">=</span> <span class="fu">mean</span>(data<span class="sc">$</span>hours)</span>
<span id="cb56-5"><a href="#cb56-5" tabindex="-1"></a><span class="co"># 编写函数</span></span>
<span id="cb56-6"><a href="#cb56-6" tabindex="-1"></a>lambda <span class="ot">=</span> <span class="cf">function</span>(dat, ind) {</span>
<span id="cb56-7"><a href="#cb56-7" tabindex="-1"></a>  <span class="fu">mean</span>(dat[ind, <span class="dv">1</span>]) }</span></code></pre></div>
<div class="sourceCode" id="cb57"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb57-1"><a href="#cb57-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">5</span>)</span>
<span id="cb57-2"><a href="#cb57-2" tabindex="-1"></a>boot_result <span class="ot">=</span> <span class="fu">boot</span>(data, <span class="at">statistic =</span> lambda, <span class="at">R=</span><span class="dv">2000</span>)</span>
<span id="cb57-3"><a href="#cb57-3" tabindex="-1"></a>boot_CI <span class="ot">=</span> <span class="fu">boot.ci</span>(boot_result, <span class="at">type=</span><span class="fu">c</span>(<span class="st">&quot;norm&quot;</span>, <span class="st">&quot;basic&quot;</span>, <span class="st">&quot;perc&quot;</span>, <span class="st">&quot;bca&quot;</span>))</span>
<span id="cb57-4"><a href="#cb57-4" tabindex="-1"></a><span class="fu">print</span>(boot_CI)</span></code></pre></div>
<pre><code>## BOOTSTRAP CONFIDENCE INTERVAL CALCULATIONS
## Based on 2000 bootstrap replicates
## 
## CALL : 
## boot.ci(boot.out = boot_result, type = c(&quot;norm&quot;, &quot;basic&quot;, &quot;perc&quot;, 
##     &quot;bca&quot;))
## 
## Intervals : 
## Level      Normal              Basic         
## 95%   ( 36.7, 180.1 )   ( 24.8, 168.7 )  
## 
## Level     Percentile            BCa          
## 95%   ( 47.5, 191.4 )   ( 58.2, 223.7 )  
## Calculations and Intervals on Original Scale
## Some BCa intervals may be unstable</code></pre>
<p>根据区间值可以看出，BCa置信区间的左右端点都是四个区间中最高的，而Basic置信区间的左右端点则是四个区间中最低的。这是由于Basic置信区间是基于大样本假定的，普适性强，但效果也不如其它区间。而其它区间分别带有一定的假定或进行了校正。</p>
<p>（2）自己编写的standard normal interval代码及结果：</p>
<div class="sourceCode" id="cb59"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb59-1"><a href="#cb59-1" tabindex="-1"></a><span class="co"># global variables</span></span>
<span id="cb59-2"><a href="#cb59-2" tabindex="-1"></a>lam0 <span class="ot">=</span> <span class="fu">mean</span>(data<span class="sc">$</span>hours)</span>
<span id="cb59-3"><a href="#cb59-3" tabindex="-1"></a>conf <span class="ot">=</span> <span class="fl">0.05</span></span>
<span id="cb59-4"><a href="#cb59-4" tabindex="-1"></a>alpha <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">1</span> <span class="sc">-</span> conf<span class="sc">/</span><span class="dv">2</span>, conf<span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb59-5"><a href="#cb59-5" tabindex="-1"></a>zalpha <span class="ot">=</span> <span class="fu">qnorm</span>(alpha)</span>
<span id="cb59-6"><a href="#cb59-6" tabindex="-1"></a>B <span class="ot">=</span> <span class="dv">2000</span></span>
<span id="cb59-7"><a href="#cb59-7" tabindex="-1"></a>n <span class="ot">=</span> <span class="fu">nrow</span>(data)</span>
<span id="cb59-8"><a href="#cb59-8" tabindex="-1"></a></span>
<span id="cb59-9"><a href="#cb59-9" tabindex="-1"></a>lam.normal <span class="ot">=</span> lam.basic <span class="ot">=</span> lam.bca <span class="ot">=</span> <span class="fu">numeric</span>(B)</span>
<span id="cb59-10"><a href="#cb59-10" tabindex="-1"></a><span class="cf">for</span> (b <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>B) {</span>
<span id="cb59-11"><a href="#cb59-11" tabindex="-1"></a>  i <span class="ot">=</span> <span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span>n, <span class="at">size =</span> n, <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb59-12"><a href="#cb59-12" tabindex="-1"></a>  dat <span class="ot">=</span> data<span class="sc">$</span>hours[i]</span>
<span id="cb59-13"><a href="#cb59-13" tabindex="-1"></a>  lam.normal[b] <span class="ot">=</span> lam.basic[b] <span class="ot">=</span> lam.bca[b] <span class="ot">=</span> <span class="fu">mean</span>(dat)</span>
<span id="cb59-14"><a href="#cb59-14" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb60"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb60-1"><a href="#cb60-1" tabindex="-1"></a><span class="co"># normal</span></span>
<span id="cb60-2"><a href="#cb60-2" tabindex="-1"></a>se.normal <span class="ot">=</span> <span class="fu">sd</span>(lam.normal)</span>
<span id="cb60-3"><a href="#cb60-3" tabindex="-1"></a>CI.normal <span class="ot">=</span> lam0 <span class="sc">-</span> zalpha<span class="sc">*</span>se.normal</span>
<span id="cb60-4"><a href="#cb60-4" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&#39;95% standard normal interval = (&#39;</span>, CI.normal[<span class="dv">1</span>], <span class="st">&#39;,&#39;</span>, CI.normal[<span class="dv">2</span>], <span class="st">&#39;)&#39;</span>)</span></code></pre></div>
<pre><code>## 95% standard normal interval = ( 33.29689 , 182.8698 )</code></pre>
<p>（3）自己编写的basic interval代码及结果：</p>
<div class="sourceCode" id="cb62"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb62-1"><a href="#cb62-1" tabindex="-1"></a><span class="co"># basic</span></span>
<span id="cb62-2"><a href="#cb62-2" tabindex="-1"></a>lam.quant <span class="ot">=</span> <span class="fu">quantile</span>(lam.basic, alpha)</span>
<span id="cb62-3"><a href="#cb62-3" tabindex="-1"></a>CI.basic <span class="ot">=</span> <span class="dv">2</span><span class="sc">*</span>lam0 <span class="sc">-</span> lam.quant</span>
<span id="cb62-4"><a href="#cb62-4" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&#39;95% basic interval = (&#39;</span>, CI.basic[<span class="dv">1</span>], <span class="st">&#39;,&#39;</span>, CI.basic[<span class="dv">2</span>], <span class="st">&#39;)&#39;</span>)</span></code></pre></div>
<pre><code>## 95% basic interval = ( 22.73958 , 169.9187 )</code></pre>
<p>（4）自己编写的percentile interval代码及结果：</p>
<div class="sourceCode" id="cb64"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb64-1"><a href="#cb64-1" tabindex="-1"></a><span class="co"># percentile</span></span>
<span id="cb64-2"><a href="#cb64-2" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&#39;95% percentile interval = (&#39;</span>, lam.quant[<span class="dv">2</span>], <span class="st">&#39;,&#39;</span>, lam.quant[<span class="dv">1</span>], <span class="st">&#39;)&#39;</span>)</span></code></pre></div>
<pre><code>## 95% percentile interval = ( 46.24792 , 193.4271 )</code></pre>
<p>（5）自己编写的BCa interval代码及结果：</p>
<div class="sourceCode" id="cb66"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb66-1"><a href="#cb66-1" tabindex="-1"></a><span class="co"># bca</span></span>
<span id="cb66-2"><a href="#cb66-2" tabindex="-1"></a>BCa <span class="ot">=</span> <span class="cf">function</span>(dat, lam0, lam, stat, conf){</span>
<span id="cb66-3"><a href="#cb66-3" tabindex="-1"></a>  dat <span class="ot">=</span> <span class="fu">as.matrix</span>(dat)</span>
<span id="cb66-4"><a href="#cb66-4" tabindex="-1"></a>  n <span class="ot">=</span> <span class="fu">nrow</span>(dat)</span>
<span id="cb66-5"><a href="#cb66-5" tabindex="-1"></a>  N <span class="ot">=</span> <span class="dv">1</span><span class="sc">:</span>n</span>
<span id="cb66-6"><a href="#cb66-6" tabindex="-1"></a>  alpha <span class="ot">=</span> <span class="fu">c</span>(conf<span class="sc">/</span><span class="dv">2</span>, <span class="dv">1</span> <span class="sc">-</span> conf<span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb66-7"><a href="#cb66-7" tabindex="-1"></a>  zalpha <span class="ot">=</span> <span class="fu">qnorm</span>(alpha)</span>
<span id="cb66-8"><a href="#cb66-8" tabindex="-1"></a>  z0 <span class="ot">=</span> <span class="fu">qnorm</span>(<span class="fu">sum</span>(lam <span class="sc">&lt;</span> lam0) <span class="sc">/</span> <span class="fu">length</span>(lam)) <span class="co"># length(lam) = B</span></span>
<span id="cb66-9"><a href="#cb66-9" tabindex="-1"></a>  </span>
<span id="cb66-10"><a href="#cb66-10" tabindex="-1"></a>  lam.jack <span class="ot">=</span> <span class="fu">numeric</span>(n)</span>
<span id="cb66-11"><a href="#cb66-11" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n) {</span>
<span id="cb66-12"><a href="#cb66-12" tabindex="-1"></a>    J <span class="ot">=</span> N[<span class="dv">1</span><span class="sc">:</span>(n<span class="dv">-1</span>)] <span class="co"># 为了和dat[-i, ]的index对应</span></span>
<span id="cb66-13"><a href="#cb66-13" tabindex="-1"></a>    jack.data <span class="ot">=</span> <span class="fu">as.data.frame</span>(dat[<span class="sc">-</span>i,<span class="dv">1</span>])</span>
<span id="cb66-14"><a href="#cb66-14" tabindex="-1"></a>    lam.jack[i] <span class="ot">&lt;-</span> <span class="fu">stat</span>(jack.data, J)</span>
<span id="cb66-15"><a href="#cb66-15" tabindex="-1"></a>  }</span>
<span id="cb66-16"><a href="#cb66-16" tabindex="-1"></a>  L <span class="ot">=</span> <span class="fu">mean</span>(lam.jack) <span class="sc">-</span> lam.jack</span>
<span id="cb66-17"><a href="#cb66-17" tabindex="-1"></a>  a <span class="ot">=</span> <span class="fu">sum</span>(L<span class="sc">^</span><span class="dv">3</span>)<span class="sc">/</span>(<span class="dv">6</span> <span class="sc">*</span> <span class="fu">sum</span>(L<span class="sc">^</span><span class="dv">2</span>)<span class="sc">^</span><span class="fl">1.5</span>)</span>
<span id="cb66-18"><a href="#cb66-18" tabindex="-1"></a>  hat.alpha <span class="ot">=</span> <span class="fu">pnorm</span>(z0 <span class="sc">+</span> (z0<span class="sc">+</span>zalpha)<span class="sc">/</span>(<span class="dv">1</span><span class="sc">-</span>a<span class="sc">*</span>(z0<span class="sc">+</span>zalpha)))</span>
<span id="cb66-19"><a href="#cb66-19" tabindex="-1"></a>  </span>
<span id="cb66-20"><a href="#cb66-20" tabindex="-1"></a>  limits <span class="ot">=</span> <span class="fu">quantile</span>(lam, hat.alpha, <span class="at">type=</span><span class="dv">6</span>) <span class="co"># the formula below 7.9</span></span>
<span id="cb66-21"><a href="#cb66-21" tabindex="-1"></a>  <span class="fu">return</span>(<span class="st">&quot;BCa&quot;</span><span class="ot">=</span>limits)</span>
<span id="cb66-22"><a href="#cb66-22" tabindex="-1"></a>}</span>
<span id="cb66-23"><a href="#cb66-23" tabindex="-1"></a></span>
<span id="cb66-24"><a href="#cb66-24" tabindex="-1"></a><span class="fu">BCa</span>(data, <span class="at">lam0 =</span> lam0, <span class="at">lam =</span> lam.bca, <span class="at">stat =</span> lambda, <span class="at">conf =</span> conf)</span></code></pre></div>
<pre><code>## 7.945344% 99.71421% 
##  58.41667 231.33871</code></pre>
<p>将结果与自带函数的结果对比，非常接近，说明我们自己编写的函数是正确的。</p>
</div>
<div id="第二题-4" class="section level2">
<h2>第二题</h2>
<p><em>问题描述：</em>数据是n个学生五场考试的成绩，记数据的协方差矩阵为<span class="math inline">\(\Sigma\)</span>，特征值为<span class="math inline">\(\lambda_1&gt;\lambda_2&gt;...&gt;\lambda_5\)</span>。在主成分分析中，
<span class="math display">\[\hat\theta=\dfrac{\hat\lambda_1}{\sum_{i=1}^5\hat\lambda_i},\]</span>
其中，<span class="math inline">\(\hat\lambda_1&gt;\hat\lambda_2&gt;...&gt;\hat\lambda_5\)</span>是
<span class="math inline">\(\Sigma\)</span>的MLE估计<span class="math inline">\(\hat\Sigma\)</span>的特征值。 计算<span class="math inline">\(\theta\)</span>的bias和standard
error的jacknife估计。</p>
<p><em>思路：</em>这题本质上是要用jacknife估计数据的协方差矩阵，然后再求特征值，计算<span class="math inline">\(\hat\theta\)</span>，最后再求bias和standard
error。</p>
<p><em>解：</em> 对于统计量<span class="math inline">\(\hat\theta\)</span>，bias的jacknife估计为： <span class="math display">\[\hat{bias}=(n-1)(\bar{\hat\theta}_{(\cdot)}-\hat\theta,)\]</span>
其中，<span class="math inline">\(\bar{\hat\theta}_{(\cdot)}=\frac{1}{n}\sum_{i=1}^n\hat\theta_{(i)}\)</span>，<span class="math inline">\(\hat\theta\)</span>是用全部样本计算的估计值。</p>
<p>standard error的jacknife估计为： <span class="math display">\[\hat{se}=\sqrt{\dfrac{n-1}{n}\sum_{i=1}^n(\hat\theta_{(i)}-\bar{\hat\theta}_{(\cdot)})^2}.\]</span>
我们首先导入数据，并根据<span class="math inline">\(\hat\theta\)</span>的表达式，写出相应的函数<code>theta.fun</code>。</p>
<div class="sourceCode" id="cb68"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb68-1"><a href="#cb68-1" tabindex="-1"></a><span class="fu">library</span>(bootstrap)</span>
<span id="cb68-2"><a href="#cb68-2" tabindex="-1"></a>data <span class="ot">=</span> scor</span>
<span id="cb68-3"><a href="#cb68-3" tabindex="-1"></a>n <span class="ot">=</span> <span class="fu">nrow</span>(data)</span>
<span id="cb68-4"><a href="#cb68-4" tabindex="-1"></a>cov.fun <span class="ot">=</span> <span class="cf">function</span>(data, ind){<span class="fu">cov</span>(data[ind, ], <span class="at">method =</span> <span class="st">&quot;pearson&quot;</span>)}</span>
<span id="cb68-5"><a href="#cb68-5" tabindex="-1"></a>theta.fun <span class="ot">=</span> <span class="cf">function</span>(lambda){lambda[<span class="dv">1</span>]<span class="sc">/</span><span class="fu">sum</span>(lambda)}</span></code></pre></div>
<p>接下来，开始正式计算：</p>
<div class="sourceCode" id="cb69"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb69-1"><a href="#cb69-1" tabindex="-1"></a>jack_th <span class="ot">=</span> <span class="fu">numeric</span>(n)</span>
<span id="cb69-2"><a href="#cb69-2" tabindex="-1"></a>orig_sigma <span class="ot">=</span> <span class="fu">cov.fun</span>(data)</span>
<span id="cb69-3"><a href="#cb69-3" tabindex="-1"></a>orig_th <span class="ot">=</span> <span class="fu">theta.fun</span>(<span class="fu">eigen</span>(orig_sigma)<span class="sc">$</span>values)</span>
<span id="cb69-4"><a href="#cb69-4" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n) {</span>
<span id="cb69-5"><a href="#cb69-5" tabindex="-1"></a>    jack_sigma <span class="ot">=</span> <span class="fu">cov.fun</span>(data, <span class="sc">-</span>i)</span>
<span id="cb69-6"><a href="#cb69-6" tabindex="-1"></a>    jack_th[i] <span class="ot">=</span> <span class="fu">theta.fun</span>(<span class="fu">eigen</span>(jack_sigma)<span class="sc">$</span>values)</span>
<span id="cb69-7"><a href="#cb69-7" tabindex="-1"></a>}</span>
<span id="cb69-8"><a href="#cb69-8" tabindex="-1"></a>bias <span class="ot">=</span> (n <span class="sc">-</span> <span class="dv">1</span>) <span class="sc">*</span> (<span class="fu">mean</span>(jack_th) <span class="sc">-</span> orig_th)</span>
<span id="cb69-9"><a href="#cb69-9" tabindex="-1"></a>se <span class="ot">&lt;-</span> <span class="fu">sqrt</span>((n<span class="dv">-1</span>) <span class="sc">*</span> <span class="fu">mean</span>((jack_th <span class="sc">-</span> <span class="fu">mean</span>(jack_th))<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb69-10"><a href="#cb69-10" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&#39;jackknife estimate of bias is:&#39;</span>, bias)</span></code></pre></div>
<pre><code>## jackknife estimate of bias is: 0.001069139</code></pre>
<div class="sourceCode" id="cb71"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb71-1"><a href="#cb71-1" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&#39;jackknife estimate of standard error is:&#39;</span>, se)</span></code></pre></div>
<pre><code>## jackknife estimate of standard error is: 0.04955231</code></pre>
</div>
<div id="第三题-4" class="section level2">
<h2>第三题</h2>
<p><em>问题描述：</em>例7.18使用的是留一（n 折）交叉验证来选择
最合适的模型。使用留二交叉验证来比较模型。</p>
<p><em>思路：</em>留二交叉验证就是保留两个样本，在余下的样本上训练模型并计算模型的评价准则，选择MSE最小的模型作为最合适的模型。</p>
<p><em>解：</em>本题共有四个模型，</p>
<ol style="list-style-type: decimal">
<li><p>Linear: <span class="math inline">\(Y = \beta_0 + \beta_1X +
\varepsilon\)</span>.</p></li>
<li><p>Quadratic: <span class="math inline">\(Y = \beta_0 + \beta_1X +
\beta_2X2 + \varepsilon\)</span>.</p></li>
<li><p>Exponential: <span class="math inline">\(\log(Y ) = \log(\beta_0)
+ \beta_1X + \varepsilon\)</span>.</p></li>
<li><p>Log-Log: <span class="math inline">\(\log(Y ) = \beta_0 + \beta_1
\log(X) + \varepsilon\)</span>.</p></li>
</ol>
<p>留二交叉验证法的基本思想是每次保留两个样本，在余下的样本上训练模型，直到遍历所有样本。因此总循环次数为<span class="math inline">\(C_n^2\)</span>。分别在这四个模型上使用留二交叉验证法，模型的评价准则为MSE最小。</p>
<div class="sourceCode" id="cb73"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb73-1"><a href="#cb73-1" tabindex="-1"></a><span class="fu">library</span>(DAAG)</span>
<span id="cb73-2"><a href="#cb73-2" tabindex="-1"></a>magnetic <span class="ot">=</span> ironslag<span class="sc">$</span>magnetic</span>
<span id="cb73-3"><a href="#cb73-3" tabindex="-1"></a>chemical <span class="ot">=</span> ironslag<span class="sc">$</span>chemical</span>
<span id="cb73-4"><a href="#cb73-4" tabindex="-1"></a>n <span class="ot">=</span> <span class="fu">length</span>(magnetic)</span>
<span id="cb73-5"><a href="#cb73-5" tabindex="-1"></a>e1 <span class="ot">=</span> e2 <span class="ot">=</span> e3 <span class="ot">=</span> e4 <span class="ot">=</span> <span class="fu">matrix</span>(<span class="cn">NA</span>, <span class="fu">choose</span>(n, <span class="dv">2</span>), <span class="dv">2</span>)</span>
<span id="cb73-6"><a href="#cb73-6" tabindex="-1"></a></span>
<span id="cb73-7"><a href="#cb73-7" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n<span class="dv">-1</span>) {</span>
<span id="cb73-8"><a href="#cb73-8" tabindex="-1"></a>  <span class="cf">for</span> (j <span class="cf">in</span> (i<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>n) {</span>
<span id="cb73-9"><a href="#cb73-9" tabindex="-1"></a>    k <span class="ot">=</span> (i<span class="dv">-1</span>)<span class="sc">*</span>(n<span class="sc">-</span>i<span class="sc">/</span><span class="dv">2</span>) <span class="sc">+</span> (j<span class="sc">-</span>i)</span>
<span id="cb73-10"><a href="#cb73-10" tabindex="-1"></a>    y <span class="ot">&lt;-</span> magnetic[<span class="sc">-</span><span class="fu">c</span>(i,j)]</span>
<span id="cb73-11"><a href="#cb73-11" tabindex="-1"></a>    x <span class="ot">&lt;-</span> chemical[<span class="sc">-</span><span class="fu">c</span>(i,j)]</span>
<span id="cb73-12"><a href="#cb73-12" tabindex="-1"></a>    J1 <span class="ot">&lt;-</span> <span class="fu">lm</span>(y <span class="sc">~</span> x)</span>
<span id="cb73-13"><a href="#cb73-13" tabindex="-1"></a>    yhat1 <span class="ot">&lt;-</span> J1<span class="sc">$</span>coef[<span class="dv">1</span>] <span class="sc">+</span> J1<span class="sc">$</span>coef[<span class="dv">2</span>] <span class="sc">*</span> chemical[<span class="fu">c</span>(i,j)]</span>
<span id="cb73-14"><a href="#cb73-14" tabindex="-1"></a>    e1[k, ] <span class="ot">&lt;-</span> magnetic[<span class="fu">c</span>(i,j)] <span class="sc">-</span> yhat1</span>
<span id="cb73-15"><a href="#cb73-15" tabindex="-1"></a>    </span>
<span id="cb73-16"><a href="#cb73-16" tabindex="-1"></a>    J2 <span class="ot">&lt;-</span> <span class="fu">lm</span>(y <span class="sc">~</span> x <span class="sc">+</span> <span class="fu">I</span>(x<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb73-17"><a href="#cb73-17" tabindex="-1"></a>    yhat2 <span class="ot">&lt;-</span> J2<span class="sc">$</span>coef[<span class="dv">1</span>] <span class="sc">+</span> J2<span class="sc">$</span>coef[<span class="dv">2</span>] <span class="sc">*</span> chemical[<span class="fu">c</span>(i,j)] <span class="sc">+</span></span>
<span id="cb73-18"><a href="#cb73-18" tabindex="-1"></a>      J2<span class="sc">$</span>coef[<span class="dv">3</span>] <span class="sc">*</span> chemical[<span class="fu">c</span>(i,j)]<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb73-19"><a href="#cb73-19" tabindex="-1"></a>    e2[k, ] <span class="ot">&lt;-</span> magnetic[<span class="fu">c</span>(i,j)] <span class="sc">-</span> yhat2</span>
<span id="cb73-20"><a href="#cb73-20" tabindex="-1"></a>    </span>
<span id="cb73-21"><a href="#cb73-21" tabindex="-1"></a>    J3 <span class="ot">&lt;-</span> <span class="fu">lm</span>(<span class="fu">log</span>(y) <span class="sc">~</span> x)</span>
<span id="cb73-22"><a href="#cb73-22" tabindex="-1"></a>    logyhat3 <span class="ot">&lt;-</span> J3<span class="sc">$</span>coef[<span class="dv">1</span>] <span class="sc">+</span> J3<span class="sc">$</span>coef[<span class="dv">2</span>] <span class="sc">*</span> chemical[<span class="fu">c</span>(i,j)]</span>
<span id="cb73-23"><a href="#cb73-23" tabindex="-1"></a>    yhat3 <span class="ot">&lt;-</span> <span class="fu">exp</span>(logyhat3)</span>
<span id="cb73-24"><a href="#cb73-24" tabindex="-1"></a>    e3[k, ] <span class="ot">&lt;-</span> magnetic[<span class="fu">c</span>(i,j)] <span class="sc">-</span> yhat3</span>
<span id="cb73-25"><a href="#cb73-25" tabindex="-1"></a>    </span>
<span id="cb73-26"><a href="#cb73-26" tabindex="-1"></a>    J4 <span class="ot">&lt;-</span> <span class="fu">lm</span>(<span class="fu">log</span>(y) <span class="sc">~</span> <span class="fu">log</span>(x))</span>
<span id="cb73-27"><a href="#cb73-27" tabindex="-1"></a>    logyhat4 <span class="ot">&lt;-</span> J4<span class="sc">$</span>coef[<span class="dv">1</span>] <span class="sc">+</span> J4<span class="sc">$</span>coef[<span class="dv">2</span>] <span class="sc">*</span> <span class="fu">log</span>(chemical[<span class="fu">c</span>(i,j)])</span>
<span id="cb73-28"><a href="#cb73-28" tabindex="-1"></a>    yhat4 <span class="ot">&lt;-</span> <span class="fu">exp</span>(logyhat4)</span>
<span id="cb73-29"><a href="#cb73-29" tabindex="-1"></a>    e4[k, ] <span class="ot">&lt;-</span> magnetic[<span class="fu">c</span>(i,j)] <span class="sc">-</span> yhat4</span>
<span id="cb73-30"><a href="#cb73-30" tabindex="-1"></a>  }</span>
<span id="cb73-31"><a href="#cb73-31" tabindex="-1"></a>}</span>
<span id="cb73-32"><a href="#cb73-32" tabindex="-1"></a><span class="fu">c</span>(<span class="fu">mean</span>(e1<span class="sc">^</span><span class="dv">2</span>), <span class="fu">mean</span>(e2<span class="sc">^</span><span class="dv">2</span>), <span class="fu">mean</span>(e3<span class="sc">^</span><span class="dv">2</span>), <span class="fu">mean</span>(e4<span class="sc">^</span><span class="dv">2</span>))</span></code></pre></div>
<pre><code>## [1] 19.57227 17.87018 18.45491 20.46718</code></pre>
<p>根据输出的MSE可知，第二个模型是最合适的模型。这一结论与留一交叉验证的结论相同。在全部数据上训练模型2，拟合的结果如下：</p>
<div class="sourceCode" id="cb75"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb75-1"><a href="#cb75-1" tabindex="-1"></a>L2 <span class="ot">&lt;-</span> <span class="fu">lm</span>(magnetic <span class="sc">~</span> chemical <span class="sc">+</span> <span class="fu">I</span>(chemical<span class="sc">^</span><span class="dv">2</span>))</span>
<span id="cb75-2"><a href="#cb75-2" tabindex="-1"></a>L2</span></code></pre></div>
<pre><code>## 
## Call:
## lm(formula = magnetic ~ chemical + I(chemical^2))
## 
## Coefficients:
##   (Intercept)       chemical  I(chemical^2)  
##      24.49262       -1.39334        0.05452</code></pre>
</div>
</div>
<div id="hw6" class="section level1">
<h1>HW6</h1>
<div id="第一题-5" class="section level2">
<h2>第一题</h2>
<p><em>问题描述：</em>证明Metropolis-Hastings
sampler算法在连续情形下的平稳性。</p>
<p><em>证：</em>首先给出一些符号的定义。记接受概率<span class="math inline">\(\alpha(s,r)\)</span>为： <span class="math display">\[\alpha(s,r) =
\min\{\dfrac{f(r)q(s|r)}{f(s)q(r|s)},1\},\]</span> 其中，<span class="math inline">\(f(\cdot)\)</span>为目标分布的概率密度函数，<span class="math inline">\(q(s|r)\)</span>为提议分布。</p>
<p>转移概率<span class="math inline">\(p(s,r)\)</span>为： <span class="math display">\[p(s,r)=q(s|r)\alpha(s,r).\]</span></p>
<p>接下来，要证明平稳性，即证明<span class="math inline">\(f(s)p(s,r) =
f(r)p(r,s)\)</span>：</p>
<p>（1）<span class="math inline">\(r=s\)</span>：显然成立；</p>
<p>（2）<span class="math inline">\(r\neq s\)</span>： <span class="math display">\[f(s)p(s,r) = f(s)q(r|s)\alpha(s,r) =
f(s)q(r|s)\min\{\dfrac{f(r)q(s|r)}{f(s)q(r|s)},1\}\]</span></p>
<p><span class="math display">\[ =\left\{
\begin{array}{rcl}
f(r)q(s|r),       &amp;      &amp; {f(s)q(r|s)\geq f(r)q(s|r)}\\
f(s)q(r|s),     &amp;      &amp; {f(s)q(r|s)&lt; f(r)q(s|r)}
\end{array} \right. \]</span></p>
<p>同理可得： <span class="math display">\[f(r)p(r,s) =
f(r)q(s|r)\alpha(r,s) =
f(r)q(s|r)\min\{\dfrac{f(s)q(r|s)}{f(r)q(s|r)},1\}\]</span></p>
<p><span class="math display">\[ =\left\{
\begin{array}{rcl}
f(r)q(s|r),       &amp;      &amp; {f(s)q(r|s)\geq f(r)q(s|r)}\\
f(s)q(r|s),     &amp;      &amp; {f(s)q(r|s)&lt; f(r)q(s|r)}
\end{array} \right. \]</span></p>
<p>综上，即证得<span class="math inline">\(f(s)p(s,r) =
f(r)p(r,s)\)</span>，Metropolis-Hastings
sampler算法在连续情形下也具有平稳性。</p>
</div>
<div id="第二题-5" class="section level2">
<h2>第二题</h2>
<p><em>问题描述：</em>在例8.1和8.2的数据上，使用两样本Cramer-von Mises
test作为permutation test来检验分布相等性。</p>
<p><em>思路：</em>按照Cramer-von Mises 统计量的定义，编写出统计量<span class="math inline">\(W_2\)</span>的程序。然后通过R次replicates，比较每一次replicate的统计量与全部样本数据计算得到的统计量，从而计算出检验的p值，判断分布是否相等。</p>
<p><em>解：</em>检验的假设为： <span class="math display">\[H_0:~F=G~~vs~~H_1:~F\neq G.\]</span>
检验分布相等的Cramer-von Mises test的统计量定义如下： <span class="math display">\[W_2 =
\dfrac{mn}{(m+n)^2}[\sum_{i=1}^n(F_n(x_i)-G_m(x_i))^2+\sum_{j=1}^m(F_n(y_j)-G_m(y_j))^2],\]</span>
其中，<span class="math inline">\(F_n\)</span>是样本<span class="math inline">\(x_1,...x_n\)</span>的ecdf，<span class="math inline">\(G_m\)</span>是样本<span class="math inline">\(y_1,...y_m\)</span>的ecdf。记<span class="math inline">\(r_i\)</span>，<span class="math inline">\(s_j\)</span>分别为秩序统计量<span class="math inline">\(x_{(i)}\)</span>，<span class="math inline">\(y_{(j)}\)</span>在混合样本中的秩，则ecdf的计算公式如下：
<span class="math display">\[F_n(x_{(i)})-G_m(x_{(i)})=\dfrac{i}{n}-\dfrac{r_i-i}{m},\]</span>
<span class="math display">\[F_n(y_{(j)})-G_m(y_{(j)})=\dfrac{s_j-j}{n}-\dfrac{j}{m}.\]</span></p>
<p>本题的代码如下，replicates的次数为999：</p>
<div class="sourceCode" id="cb77"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb77-1"><a href="#cb77-1" tabindex="-1"></a><span class="co"># 导入数据</span></span>
<span id="cb77-2"><a href="#cb77-2" tabindex="-1"></a><span class="fu">attach</span>(chickwts)</span>
<span id="cb77-3"><a href="#cb77-3" tabindex="-1"></a>x <span class="ot">=</span> <span class="fu">as.vector</span>(weight[feed<span class="sc">==</span><span class="st">&#39;soybean&#39;</span>])</span>
<span id="cb77-4"><a href="#cb77-4" tabindex="-1"></a>y <span class="ot">=</span> <span class="fu">as.vector</span>(weight[feed<span class="sc">==</span><span class="st">&#39;linseed&#39;</span>])</span>
<span id="cb77-5"><a href="#cb77-5" tabindex="-1"></a><span class="fu">detach</span>(chickwts)</span></code></pre></div>
<div class="sourceCode" id="cb78"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb78-1"><a href="#cb78-1" tabindex="-1"></a>R <span class="ot">=</span> <span class="dv">999</span></span>
<span id="cb78-2"><a href="#cb78-2" tabindex="-1"></a>z <span class="ot">=</span> <span class="fu">c</span>(x, y)</span>
<span id="cb78-3"><a href="#cb78-3" tabindex="-1"></a>n <span class="ot">=</span> <span class="fu">length</span>(x)</span>
<span id="cb78-4"><a href="#cb78-4" tabindex="-1"></a>m <span class="ot">=</span> <span class="fu">length</span>(y)</span>
<span id="cb78-5"><a href="#cb78-5" tabindex="-1"></a><span class="co"># 计算每一个元素的经验累计密度函数值，前n个元素为x，后m个元素为y</span></span>
<span id="cb78-6"><a href="#cb78-6" tabindex="-1"></a>ecdf_x <span class="ot">=</span> <span class="fu">rank</span>(x)<span class="sc">/</span>n <span class="sc">-</span> (<span class="fu">rank</span>(z)[<span class="dv">1</span><span class="sc">:</span><span class="dv">14</span>]<span class="sc">-</span><span class="fu">rank</span>(x))<span class="sc">/</span>m</span>
<span id="cb78-7"><a href="#cb78-7" tabindex="-1"></a>ecdf_y <span class="ot">=</span> (<span class="fu">rank</span>(z)[<span class="dv">15</span><span class="sc">:</span><span class="dv">26</span>]<span class="sc">-</span><span class="fu">rank</span>(y))<span class="sc">/</span>n <span class="sc">-</span> <span class="fu">rank</span>(y)<span class="sc">/</span>m</span>
<span id="cb78-8"><a href="#cb78-8" tabindex="-1"></a>K <span class="ot">=</span> <span class="dv">1</span><span class="sc">:</span>(m<span class="sc">+</span>n)</span>
<span id="cb78-9"><a href="#cb78-9" tabindex="-1"></a>W_rep <span class="ot">=</span> <span class="fu">numeric</span>(R)</span>
<span id="cb78-10"><a href="#cb78-10" tabindex="-1"></a>W0 <span class="ot">=</span> m<span class="sc">*</span>n<span class="sc">*</span>((<span class="fu">sum</span>(ecdf_x<span class="sc">^</span><span class="dv">2</span>)<span class="sc">+</span><span class="fu">sum</span>(ecdf_y<span class="sc">^</span><span class="dv">2</span>)))<span class="sc">/</span>(m<span class="sc">+</span>n)<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb78-11"><a href="#cb78-11" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">5</span>)</span>
<span id="cb78-12"><a href="#cb78-12" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>R) {</span>
<span id="cb78-13"><a href="#cb78-13" tabindex="-1"></a>  k <span class="ot">=</span> <span class="fu">sample</span>(K, <span class="at">size =</span> <span class="dv">14</span>, <span class="at">replace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb78-14"><a href="#cb78-14" tabindex="-1"></a>  x1 <span class="ot">=</span> z[k]</span>
<span id="cb78-15"><a href="#cb78-15" tabindex="-1"></a>  y1 <span class="ot">=</span> z[<span class="sc">-</span>k]</span>
<span id="cb78-16"><a href="#cb78-16" tabindex="-1"></a>  z1 <span class="ot">=</span> <span class="fu">c</span>(x1, y1)</span>
<span id="cb78-17"><a href="#cb78-17" tabindex="-1"></a>  ecdf_x1 <span class="ot">=</span> <span class="fu">rank</span>(x1)<span class="sc">/</span>n <span class="sc">-</span> (<span class="fu">rank</span>(z1)[<span class="dv">1</span><span class="sc">:</span><span class="dv">14</span>]<span class="sc">-</span><span class="fu">rank</span>(x1))<span class="sc">/</span>m</span>
<span id="cb78-18"><a href="#cb78-18" tabindex="-1"></a>  ecdf_y1 <span class="ot">=</span> (<span class="fu">rank</span>(z1)[<span class="dv">15</span><span class="sc">:</span><span class="dv">26</span>]<span class="sc">-</span><span class="fu">rank</span>(y1))<span class="sc">/</span>n <span class="sc">-</span> <span class="fu">rank</span>(y1)<span class="sc">/</span>m</span>
<span id="cb78-19"><a href="#cb78-19" tabindex="-1"></a>  W_rep[i] <span class="ot">=</span> m<span class="sc">*</span>n<span class="sc">*</span>((<span class="fu">sum</span>(ecdf_x1<span class="sc">^</span><span class="dv">2</span>)<span class="sc">+</span><span class="fu">sum</span>(ecdf_y1<span class="sc">^</span><span class="dv">2</span>)))<span class="sc">/</span>(m<span class="sc">+</span>n)<span class="sc">^</span><span class="dv">2</span></span>
<span id="cb78-20"><a href="#cb78-20" tabindex="-1"></a>}</span>
<span id="cb78-21"><a href="#cb78-21" tabindex="-1"></a>p <span class="ot">=</span> <span class="fu">mean</span>(<span class="fu">c</span>(W0,W_rep)<span class="sc">&gt;=</span>W0)</span>
<span id="cb78-22"><a href="#cb78-22" tabindex="-1"></a>p</span></code></pre></div>
<pre><code>## [1] 0.391</code></pre>
<p>Cramer-von Mises
test的P值为0.391。与例题8.1和8.2相比，虽然都做出了接受原假设的判断，但CvM
test的P值比t检验的大，比KS检验的小。我们还可以通过图像了解统计量的分布情况，其中，横轴上黑色的点为原始数据计算的统计量W2.</p>
<p><img src="data:image/png;base64,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" /><!-- --></p>
</div>
<div id="第三题-5" class="section level2">
<h2>第三题</h2>
<p><em>问题描述：</em>6.4节中，方差相等的count 5
test是基于极端点的最大数量的。例6.15展示了count
5准则并不适用于样本量不相等的情况。在样本量不相等的情况下，基于极端点的最大数量，使用permutation
test来检验方差是否相等。</p>
<p><em>思路：</em>首先根据极端点数量大于5则方差不等的思想，编写函数使其具有count
5
test的功能。然后生成样本量不等、方差相等的两组数据。在R次permutation中，打乱样本顺序，实施count
5 test，计算统计量，判断是否拒绝原假设。</p>
<p><em>解：</em>
编写函数<code>count 5 test</code>，统计量为<code>max(c(extrem_x, extrem_y))</code>，如果统计量大于5，则返回值为1，拒绝<span class="math inline">\(H_0\)</span>，否则，返回值为0，没有充足理由拒绝<span class="math inline">\(H_0\)</span>。</p>
<div class="sourceCode" id="cb80"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb80-1"><a href="#cb80-1" tabindex="-1"></a>count5test <span class="ot">=</span> <span class="cf">function</span>(x, y){</span>
<span id="cb80-2"><a href="#cb80-2" tabindex="-1"></a>  x <span class="ot">=</span> x <span class="sc">-</span> <span class="fu">mean</span>(x)</span>
<span id="cb80-3"><a href="#cb80-3" tabindex="-1"></a>  y <span class="ot">=</span> y <span class="sc">-</span> <span class="fu">mean</span>(y)</span>
<span id="cb80-4"><a href="#cb80-4" tabindex="-1"></a>  <span class="co"># count</span></span>
<span id="cb80-5"><a href="#cb80-5" tabindex="-1"></a>  extrem_x <span class="ot">=</span> <span class="fu">sum</span>(x <span class="sc">&gt;</span> <span class="fu">max</span>(y)) <span class="sc">+</span> <span class="fu">sum</span>(x <span class="sc">&lt;</span> <span class="fu">min</span>(y))</span>
<span id="cb80-6"><a href="#cb80-6" tabindex="-1"></a>  extrem_y <span class="ot">=</span> <span class="fu">sum</span>(y <span class="sc">&gt;</span> <span class="fu">max</span>(x)) <span class="sc">+</span> <span class="fu">sum</span>(y <span class="sc">&lt;</span> <span class="fu">min</span>(x))</span>
<span id="cb80-7"><a href="#cb80-7" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">max</span>(<span class="fu">c</span>(extrem_x, extrem_y)))</span>
<span id="cb80-8"><a href="#cb80-8" tabindex="-1"></a>}</span></code></pre></div>
<p>为了更全面地展示结果，我们分别考虑样本方差相等和不相等的两种情况，并在每种情况下逐渐增大y的样本量。</p>
<p>（1）样本方差相等：两组正态分布样本，初始样本量分别为20、20，方差相等，均为1。replicates的次数为999。y的样本量从20增加至100，步长为10：</p>
<div class="sourceCode" id="cb81"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb81-1"><a href="#cb81-1" tabindex="-1"></a>R <span class="ot">=</span> <span class="dv">999</span></span>
<span id="cb81-2"><a href="#cb81-2" tabindex="-1"></a>n1 <span class="ot">=</span> <span class="dv">20</span></span>
<span id="cb81-3"><a href="#cb81-3" tabindex="-1"></a>mu1 <span class="ot">=</span> mu2 <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb81-4"><a href="#cb81-4" tabindex="-1"></a>sigma1 <span class="ot">=</span> sigma2 <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb81-5"><a href="#cb81-5" tabindex="-1"></a>y_seq <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">20</span>,<span class="dv">100</span>,<span class="dv">10</span>)</span>
<span id="cb81-6"><a href="#cb81-6" tabindex="-1"></a>p1 <span class="ot">=</span> <span class="fu">numeric</span>(<span class="fu">length</span>(y_seq))</span>
<span id="cb81-7"><a href="#cb81-7" tabindex="-1"></a></span>
<span id="cb81-8"><a href="#cb81-8" tabindex="-1"></a><span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(y_seq)) {</span>
<span id="cb81-9"><a href="#cb81-9" tabindex="-1"></a>  <span class="fu">set.seed</span>(<span class="dv">6</span>)</span>
<span id="cb81-10"><a href="#cb81-10" tabindex="-1"></a>  n2 <span class="ot">=</span> y_seq[j]</span>
<span id="cb81-11"><a href="#cb81-11" tabindex="-1"></a>  K <span class="ot">=</span> <span class="dv">1</span><span class="sc">:</span>(n1<span class="sc">+</span>n2)</span>
<span id="cb81-12"><a href="#cb81-12" tabindex="-1"></a>  x <span class="ot">=</span> <span class="fu">rnorm</span>(n1, mu1, sigma1)</span>
<span id="cb81-13"><a href="#cb81-13" tabindex="-1"></a>  y <span class="ot">=</span> <span class="fu">rnorm</span>(n2, mu2, sigma2)</span>
<span id="cb81-14"><a href="#cb81-14" tabindex="-1"></a>  C0 <span class="ot">=</span> <span class="fu">count5test</span>(x, y)</span>
<span id="cb81-15"><a href="#cb81-15" tabindex="-1"></a>  </span>
<span id="cb81-16"><a href="#cb81-16" tabindex="-1"></a>  C_rep <span class="ot">=</span> <span class="fu">numeric</span>(R)</span>
<span id="cb81-17"><a href="#cb81-17" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>R) {</span>
<span id="cb81-18"><a href="#cb81-18" tabindex="-1"></a>    k <span class="ot">=</span> <span class="fu">sample</span>(K, <span class="at">size =</span> n1, <span class="at">replace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb81-19"><a href="#cb81-19" tabindex="-1"></a>    z <span class="ot">=</span> <span class="fu">c</span>(x, y)</span>
<span id="cb81-20"><a href="#cb81-20" tabindex="-1"></a>    x1 <span class="ot">=</span> z[k]</span>
<span id="cb81-21"><a href="#cb81-21" tabindex="-1"></a>    y1 <span class="ot">=</span> z[<span class="sc">-</span>k]</span>
<span id="cb81-22"><a href="#cb81-22" tabindex="-1"></a>    C_rep[i] <span class="ot">=</span> <span class="fu">count5test</span>(x1, y1)</span>
<span id="cb81-23"><a href="#cb81-23" tabindex="-1"></a>  }</span>
<span id="cb81-24"><a href="#cb81-24" tabindex="-1"></a>  p1[j] <span class="ot">=</span> <span class="fu">mean</span>(<span class="fu">c</span>(C0, C_rep) <span class="sc">&gt;=</span> C0)</span>
<span id="cb81-25"><a href="#cb81-25" tabindex="-1"></a>}</span>
<span id="cb81-26"><a href="#cb81-26" tabindex="-1"></a>p1</span></code></pre></div>
<pre><code>## [1] 0.887 0.871 0.503 0.584 0.638 0.379 0.363 0.477 0.479</code></pre>
<p>（2） 样本方差不相等：
两组正态分布样本，初始样本量分别为20、20，方差分别为1和1.5。replicates的次数为999。y的样本量从20增加至100，步长为10：</p>
<div class="sourceCode" id="cb83"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb83-1"><a href="#cb83-1" tabindex="-1"></a>R <span class="ot">=</span> <span class="dv">999</span></span>
<span id="cb83-2"><a href="#cb83-2" tabindex="-1"></a>n1 <span class="ot">=</span> <span class="dv">20</span></span>
<span id="cb83-3"><a href="#cb83-3" tabindex="-1"></a>mu1 <span class="ot">=</span> mu2 <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb83-4"><a href="#cb83-4" tabindex="-1"></a>sigma1 <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb83-5"><a href="#cb83-5" tabindex="-1"></a>sigma2 <span class="ot">=</span> <span class="fl">1.5</span></span>
<span id="cb83-6"><a href="#cb83-6" tabindex="-1"></a>y_seq <span class="ot">=</span> <span class="fu">seq</span>(<span class="dv">20</span>,<span class="dv">100</span>,<span class="dv">10</span>)</span>
<span id="cb83-7"><a href="#cb83-7" tabindex="-1"></a>p2 <span class="ot">=</span> <span class="fu">numeric</span>(<span class="fu">length</span>(y_seq))</span>
<span id="cb83-8"><a href="#cb83-8" tabindex="-1"></a></span>
<span id="cb83-9"><a href="#cb83-9" tabindex="-1"></a><span class="cf">for</span> (j <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(y_seq)) {</span>
<span id="cb83-10"><a href="#cb83-10" tabindex="-1"></a>  <span class="fu">set.seed</span>(<span class="dv">6</span>)</span>
<span id="cb83-11"><a href="#cb83-11" tabindex="-1"></a>  n2 <span class="ot">=</span> y_seq[j]</span>
<span id="cb83-12"><a href="#cb83-12" tabindex="-1"></a>  K <span class="ot">=</span> <span class="dv">1</span><span class="sc">:</span>(n1<span class="sc">+</span>n2)</span>
<span id="cb83-13"><a href="#cb83-13" tabindex="-1"></a>  x <span class="ot">=</span> <span class="fu">rnorm</span>(n1, mu1, sigma1)</span>
<span id="cb83-14"><a href="#cb83-14" tabindex="-1"></a>  y <span class="ot">=</span> <span class="fu">rnorm</span>(n2, mu2, sigma2)</span>
<span id="cb83-15"><a href="#cb83-15" tabindex="-1"></a>  C0 <span class="ot">=</span> <span class="fu">count5test</span>(x, y)</span>
<span id="cb83-16"><a href="#cb83-16" tabindex="-1"></a>  </span>
<span id="cb83-17"><a href="#cb83-17" tabindex="-1"></a>  C_rep <span class="ot">=</span> <span class="fu">numeric</span>(R)</span>
<span id="cb83-18"><a href="#cb83-18" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>R) {</span>
<span id="cb83-19"><a href="#cb83-19" tabindex="-1"></a>    k <span class="ot">=</span> <span class="fu">sample</span>(K, <span class="at">size =</span> n1, <span class="at">replace =</span> <span class="cn">FALSE</span>)</span>
<span id="cb83-20"><a href="#cb83-20" tabindex="-1"></a>    z <span class="ot">=</span> <span class="fu">c</span>(x, y)</span>
<span id="cb83-21"><a href="#cb83-21" tabindex="-1"></a>    x1 <span class="ot">=</span> z[k]</span>
<span id="cb83-22"><a href="#cb83-22" tabindex="-1"></a>    y1 <span class="ot">=</span> z[<span class="sc">-</span>k]</span>
<span id="cb83-23"><a href="#cb83-23" tabindex="-1"></a>    C_rep[i] <span class="ot">=</span> <span class="fu">count5test</span>(x1, y1)</span>
<span id="cb83-24"><a href="#cb83-24" tabindex="-1"></a>  }</span>
<span id="cb83-25"><a href="#cb83-25" tabindex="-1"></a>  p2[j] <span class="ot">=</span> <span class="fu">mean</span>(<span class="fu">c</span>(C0, C_rep) <span class="sc">&gt;=</span> C0)</span>
<span id="cb83-26"><a href="#cb83-26" tabindex="-1"></a>}</span>
<span id="cb83-27"><a href="#cb83-27" tabindex="-1"></a>p2</span></code></pre></div>
<pre><code>## [1] 0.005 0.006 0.004 0.008 0.034 0.013 0.015 0.045 0.039</code></pre>
<p>最后，我们将结果输出成表格：</p>
<div class="sourceCode" id="cb85"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb85-1"><a href="#cb85-1" tabindex="-1"></a>value <span class="ot">=</span> <span class="fu">rbind</span>(p1, p2)</span>
<span id="cb85-2"><a href="#cb85-2" tabindex="-1"></a><span class="fu">colnames</span>(value) <span class="ot">=</span> y_seq</span>
<span id="cb85-3"><a href="#cb85-3" tabindex="-1"></a><span class="fu">rownames</span>(value) <span class="ot">=</span> <span class="fu">c</span>(<span class="st">&#39;方差相等&#39;</span>, <span class="st">&#39;方差不相等&#39;</span>)</span>
<span id="cb85-4"><a href="#cb85-4" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(<span class="fu">round</span>(value, <span class="dv">3</span>), <span class="at">format =</span> <span class="st">&quot;latex&quot;</span>, <span class="at">align=</span><span class="st">&#39;c&#39;</span>)</span></code></pre></div>
<p>表格的每一列代表y的样本量（x的样本量始终为20），第一行是在方差相等的设定下，用count
5 test检验方差是否相等的P值，第二行是在方差不相等的设定下，用count 5
test检验方差是否相等的P值。</p>
<p>在原假设成立，即样本方差相等的设定下，随着样本量不相等的程度增加，P值逐渐变小。虽然在0.05的显著性水平下，始终没有充足的理由拒绝原假设，但是P值变小说明有越来越强的倾向拒绝原假设，也就是说，样本落在拒绝域内的可能性越来越大，犯一类错误的可能性变大。</p>
<p>而在备择假设成立，即样本方差不相等的设定下，随着样本量不相等的程度增加，P值逐渐变大。虽然在0.05的显著性水平下，始终可以拒绝原假设，但是P值变大说明拒绝原假设的能力越来越弱，样本落在拒绝域内的可能性越来越小，犯二类错误的可能性变大。</p>
<p>综上所述，当样本量不相等时，count 5
test犯一类、二类错误的可能性均增加。这就是该检验的缺点。</p>
</div>
</div>
<div id="hw7" class="section level1">
<h1>HW7</h1>
<div id="第一题-6" class="section level2">
<h2>第一题</h2>
<p><em>问题描述：</em>考虑如下的模型： <span class="math display">\[P(Y=1|X_1,X_2,X_3)=\dfrac{\exp(a+b_1X_1+b_2X_2+b_3X_3)}{1+\exp(a+b_1X_1+b_2X_2+b_3X_3)},\]</span>
其中<span class="math inline">\(X_1\sim P(1)\)</span>，<span class="math inline">\(X_2\sim Exp(1)\)</span>，<span class="math inline">\(X_3\sim B(1,0.5)\)</span>。</p>
<ul>
<li><p>设计一个函数，以<span class="math inline">\(N,~b_1,~b_2,~b_3,~f_0\)</span>作为输入的参数，并输出<span class="math inline">\(a\)</span>;</p></li>
<li><p>给定具体的输入值<span class="math inline">\(N=10^6,~b_1=0,~b_2=1,~b_3=-1,~f_0=0.1,~0.01,~0.001,~0.0001\)</span>;</p></li>
<li><p>画出<span class="math inline">\(-\log
f_0~\mbox{vs}~a\)</span>的图像。</p></li>
</ul>
<p><em>思路：</em>根据模型表达式，写一个用<code>uniroot</code>方法来求解<span class="math inline">\(a\)</span>的函数。然后将题目给定的参数值输入到函数中，求解<span class="math inline">\(a\)</span>，并绘制图像。</p>
<p><em>解：</em>在设计的函数<code>alpha.solve</code>中，我们首先分别生成随机数<span class="math inline">\(X_1\)</span>，<span class="math inline">\(X_2\)</span>，<span class="math inline">\(X_3\)</span>各<span class="math inline">\(N\)</span>个。然后，<code>alpha.solve</code>调用另一个自己设计的函数<code>g.alpha</code>，<code>g.alpha</code>的功能是构建关于<span class="math inline">\(\alpha\)</span>的函数<span class="math inline">\(g(\alpha)\)</span>： <span class="math display">\[g(\alpha) =
\dfrac{1}{N}\sum_{i=1}^N\dfrac{1}{1+\exp(-\alpha-b_1x_1-b_2x_2-b_3x_3)}-f_0.\]</span>
最后用<strong>R</strong>自带的<code>uniroot</code>方法求解方程<span class="math inline">\(g(\alpha)=0\)</span>的根，输出方程的解<span class="math inline">\(a\)</span>，代码如下：</p>
<div class="sourceCode" id="cb86"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb86-1"><a href="#cb86-1" tabindex="-1"></a>alpha.solve <span class="ot">=</span> <span class="cf">function</span>(alpha, N, b1, b2, b3, f0){</span>
<span id="cb86-2"><a href="#cb86-2" tabindex="-1"></a>  x1 <span class="ot">=</span> <span class="fu">rpois</span>(N, <span class="dv">1</span>)</span>
<span id="cb86-3"><a href="#cb86-3" tabindex="-1"></a>  x2 <span class="ot">=</span> <span class="fu">rexp</span>(N, <span class="dv">1</span>)</span>
<span id="cb86-4"><a href="#cb86-4" tabindex="-1"></a>  x3 <span class="ot">=</span> <span class="fu">rbinom</span>(N, <span class="dv">1</span>, <span class="fl">0.5</span>)</span>
<span id="cb86-5"><a href="#cb86-5" tabindex="-1"></a>  g.alpha <span class="ot">=</span> <span class="cf">function</span>(alpha){</span>
<span id="cb86-6"><a href="#cb86-6" tabindex="-1"></a>  temp <span class="ot">=</span> <span class="fu">exp</span>(<span class="sc">-</span>alpha<span class="sc">-</span>b1<span class="sc">*</span>x1<span class="sc">-</span>b2<span class="sc">*</span>x2<span class="sc">-</span>b3<span class="sc">*</span>x3)</span>
<span id="cb86-7"><a href="#cb86-7" tabindex="-1"></a>  <span class="fu">mean</span>(<span class="dv">1</span><span class="sc">/</span>(<span class="dv">1</span><span class="sc">+</span>temp)) <span class="sc">-</span> f0</span>
<span id="cb86-8"><a href="#cb86-8" tabindex="-1"></a>  }</span>
<span id="cb86-9"><a href="#cb86-9" tabindex="-1"></a>  solution <span class="ot">=</span> <span class="fu">uniroot</span>(g.alpha, <span class="fu">c</span>(<span class="sc">-</span><span class="dv">20</span>, <span class="dv">20</span>))</span>
<span id="cb86-10"><a href="#cb86-10" tabindex="-1"></a>  alpha <span class="ot">=</span> <span class="fu">round</span>(solution<span class="sc">$</span>root, <span class="dv">5</span>)</span>
<span id="cb86-11"><a href="#cb86-11" tabindex="-1"></a>  <span class="fu">return</span>(alpha)</span>
<span id="cb86-12"><a href="#cb86-12" tabindex="-1"></a>}</span>
<span id="cb86-13"><a href="#cb86-13" tabindex="-1"></a></span>
<span id="cb86-14"><a href="#cb86-14" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">7</span>)</span>
<span id="cb86-15"><a href="#cb86-15" tabindex="-1"></a>f <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">0.1</span>, <span class="fl">0.01</span>, <span class="fl">0.001</span>, <span class="fl">0.0001</span>)</span>
<span id="cb86-16"><a href="#cb86-16" tabindex="-1"></a>alpha.root <span class="ot">=</span> <span class="fu">numeric</span>(<span class="fu">length</span>(f))</span>
<span id="cb86-17"><a href="#cb86-17" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(f)) {</span>
<span id="cb86-18"><a href="#cb86-18" tabindex="-1"></a>  alpha.root[i] <span class="ot">=</span> <span class="fu">alpha.solve</span>(<span class="at">N=</span><span class="fl">1e6</span>, <span class="at">b1=</span><span class="dv">0</span>, <span class="at">b2=</span><span class="dv">1</span>, <span class="at">b3=</span><span class="sc">-</span><span class="dv">1</span>, <span class="at">f0=</span>f[i])</span>
<span id="cb86-19"><a href="#cb86-19" tabindex="-1"></a>}</span>
<span id="cb86-20"><a href="#cb86-20" tabindex="-1"></a>alpha.root</span></code></pre></div>
<pre><code>## [1]  -3.16924  -6.07592  -8.72079 -11.30658</code></pre>
<p>可以看出，函数成功地输出了<span class="math inline">\(a\)</span>。接下来通过图像观察<span class="math inline">\(-\log f_0\)</span>和<span class="math inline">\(a\)</span>之间的关系，二者之间为线性关系，随着<span class="math inline">\(f_0\)</span>增加，<span class="math inline">\(-\log f_0\)</span>降低，<span class="math inline">\(a\)</span>增大。</p>
<p><img src="data:image/png;base64,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" /><!-- --></p>
</div>
<div id="第二题-6" class="section level2">
<h2>第二题</h2>
<p><em>问题描述：</em>使用随机游走Metropolis
sampler来生成标准拉普拉斯分布。增量从正态分布中生成。当提议分布的方差不同时，比较这些生成的链。此外，请比较每条链的接受率。</p>
<p><em>思路：</em>目标分布是标准拉普拉斯分布。由于增量从正态分布中生成，因此提议分布是正态分布，均值为上一步生成的随机数，方差待定。分别在提议分布的方差为0.05，0.5，2，16的条件下生成链。</p>
<p><em>解：</em>注意到当提议分布是正态分布<span class="math inline">\(N(X_t,\sigma^2)\)</span>时，<span class="math inline">\(g(r|s) = g(s|r)\)</span>，因此候选点<span class="math inline">\(Y\)</span>的接受概率为： <span class="math display">\[\alpha(X_t,Y) =
\min(1,\dfrac{f(Y)}{f(X_t)}).\]</span>
此外，标准拉普拉斯分布的密度函数是<span class="math inline">\(f(x)=\frac{1}{2}e^{-|x|},~x\in R\)</span>。</p>
<p>生成链的算法流程如下：</p>
<p>（1）指定<span class="math inline">\(X_1\)</span>为30（也可以从提议分布中生成，但这里为了比较四种方差，就固定为30）；</p>
<p>（2）第<span class="math inline">\(i(i =
1,...,N)\)</span>次循环中：</p>
<ol style="list-style-type: lower-alpha">
<li><p>从提议分布<span class="math inline">\(N(X_{i-1},\sigma^2)\)</span>中生成<span class="math inline">\(Y\)</span>；</p></li>
<li><p>从<span class="math inline">\(U(0,1)\)</span>中生成<span class="math inline">\(U\)</span>；</p></li>
<li><p>计算<span class="math inline">\(\alpha =
f(Y)/f(X_{i-1})\)</span>，如果<span class="math inline">\(U\leq
\alpha\)</span>，则接受<span class="math inline">\(Y\)</span>，并令<span class="math inline">\(X_{i}=Y\)</span>；否则令<span class="math inline">\(X_{i}=X_{i-1}\)</span>。</p></li>
</ol>
<div class="sourceCode" id="cb88"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb88-1"><a href="#cb88-1" tabindex="-1"></a><span class="co"># Metropolis函数，返回生成的样本x和接受率rate</span></span>
<span id="cb88-2"><a href="#cb88-2" tabindex="-1"></a>laplace <span class="ot">=</span> <span class="cf">function</span>(x){<span class="fu">exp</span>(<span class="sc">-</span><span class="fu">abs</span>(x))<span class="sc">/</span><span class="dv">2</span>}</span>
<span id="cb88-3"><a href="#cb88-3" tabindex="-1"></a>Metropolis <span class="ot">=</span> <span class="cf">function</span>(N, x0, sigma) {</span>
<span id="cb88-4"><a href="#cb88-4" tabindex="-1"></a>  x <span class="ot">=</span> <span class="fu">numeric</span>(N)</span>
<span id="cb88-5"><a href="#cb88-5" tabindex="-1"></a>  u <span class="ot">=</span> <span class="fu">runif</span>(N)</span>
<span id="cb88-6"><a href="#cb88-6" tabindex="-1"></a>  x[<span class="dv">1</span>] <span class="ot">=</span> x0</span>
<span id="cb88-7"><a href="#cb88-7" tabindex="-1"></a>  rate <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb88-8"><a href="#cb88-8" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>N) {</span>
<span id="cb88-9"><a href="#cb88-9" tabindex="-1"></a>    y <span class="ot">=</span> <span class="fu">rnorm</span>(<span class="dv">1</span>, x[i<span class="dv">-1</span>], sigma)</span>
<span id="cb88-10"><a href="#cb88-10" tabindex="-1"></a>    <span class="cf">if</span>(u[i] <span class="sc">&lt;=</span> <span class="fu">laplace</span>(y) <span class="sc">/</span> <span class="fu">laplace</span>(x[i<span class="dv">-1</span>])){</span>
<span id="cb88-11"><a href="#cb88-11" tabindex="-1"></a>      x[i] <span class="ot">=</span> y</span>
<span id="cb88-12"><a href="#cb88-12" tabindex="-1"></a>      rate <span class="ot">=</span> rate <span class="sc">+</span> <span class="dv">1</span></span>
<span id="cb88-13"><a href="#cb88-13" tabindex="-1"></a>    }</span>
<span id="cb88-14"><a href="#cb88-14" tabindex="-1"></a>    <span class="cf">else</span>{</span>
<span id="cb88-15"><a href="#cb88-15" tabindex="-1"></a>      x[i] <span class="ot">=</span> x[i<span class="dv">-1</span>]</span>
<span id="cb88-16"><a href="#cb88-16" tabindex="-1"></a>    }</span>
<span id="cb88-17"><a href="#cb88-17" tabindex="-1"></a>  }</span>
<span id="cb88-18"><a href="#cb88-18" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">list</span>(<span class="at">x =</span> x, <span class="at">rate =</span> rate<span class="sc">/</span>N))</span>
<span id="cb88-19"><a href="#cb88-19" tabindex="-1"></a>}</span></code></pre></div>
<p>我们在提议分布的方差为0.05，0.5，2，16的条件下生成链，每条链的样本为5000个。</p>
<div class="sourceCode" id="cb89"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb89-1"><a href="#cb89-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">7</span>)</span>
<span id="cb89-2"><a href="#cb89-2" tabindex="-1"></a>N <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb89-3"><a href="#cb89-3" tabindex="-1"></a>sigma <span class="ot">=</span> <span class="fu">c</span>(<span class="fl">0.05</span>, <span class="fl">0.5</span>, <span class="dv">2</span>,  <span class="dv">16</span>)</span>
<span id="cb89-4"><a href="#cb89-4" tabindex="-1"></a>x0 <span class="ot">=</span> <span class="dv">30</span></span>
<span id="cb89-5"><a href="#cb89-5" tabindex="-1"></a>rw1 <span class="ot">=</span> <span class="fu">Metropolis</span>(N, x0, sigma[<span class="dv">1</span>])</span>
<span id="cb89-6"><a href="#cb89-6" tabindex="-1"></a>rw2 <span class="ot">=</span> <span class="fu">Metropolis</span>(N, x0, sigma[<span class="dv">2</span>])</span>
<span id="cb89-7"><a href="#cb89-7" tabindex="-1"></a>rw3 <span class="ot">=</span> <span class="fu">Metropolis</span>(N, x0, sigma[<span class="dv">3</span>])</span>
<span id="cb89-8"><a href="#cb89-8" tabindex="-1"></a>rw4 <span class="ot">=</span> <span class="fu">Metropolis</span>(N, x0, sigma[<span class="dv">4</span>])</span>
<span id="cb89-9"><a href="#cb89-9" tabindex="-1"></a></span>
<span id="cb89-10"><a href="#cb89-10" tabindex="-1"></a><span class="co"># 输出接受率</span></span>
<span id="cb89-11"><a href="#cb89-11" tabindex="-1"></a>accepted <span class="ot">=</span> <span class="fu">data.frame</span>(<span class="at">sigma =</span> sigma, </span>
<span id="cb89-12"><a href="#cb89-12" tabindex="-1"></a>                      <span class="at">accepted.rate =</span> <span class="fu">c</span>(rw1<span class="sc">$</span>rate, rw2<span class="sc">$</span>rate, rw3<span class="sc">$</span>rate, rw4<span class="sc">$</span>rate))</span>
<span id="cb89-13"><a href="#cb89-13" tabindex="-1"></a>knitr<span class="sc">::</span><span class="fu">kable</span>(accepted,<span class="at">format=</span><span class="st">&#39;latex&#39;</span>)</span></code></pre></div>
<p>从输出的接受率的表格可以看出，随着提议分布方差增大，样本的接受率减小。但并不是接受率越大越好，因为我们需要在接受率和收敛速度之间做好平衡，才能生成理想的样本。</p>
<p>最后，通过图像来比较这些生成的链。</p>
<p><img src="data:image/png;base64,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" /><!-- --><img src="data:image/png;base64,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" /><!-- --><img src="data:image/png;base64,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" /><!-- --><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAclBMVEUAAAAAADoAAGYAOpAAZrY6AAA6ADo6AGY6OpA6ZpA6ZrY6kNtmAABmADpmOgBmZjpmZrZmtttmtv+QOgCQZgCQ2/+2ZgC2Zjq2Zma22/+2/7a2///bkDrbtpDb2//b////AAD/tmb/25D//7b//9v///9HWd2EAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAH3klEQVR4nO2daWPjJhRFX5JmusRtp5PWXcZtRk74/3+x2kAICS4gydZyz4dEtsRDHD+QkoAiigSRe5/A2qEgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBEgT9PEqNY9fFzqd9ZEk6CIvzUahN/ZPiqCPV6Pl8vS2wMmskRRB76cverM4TCebOYNkMywhqByD2hTyjkGbuSguI6jsZI1+7wh0dEG3DrccNxbkdO34Hn43lhRUiDz8EQ53WEFnkZfrD2/2BX803FEFncvB+Vxnj/cynxH1LiwiqM6b66dKkO9G8eiCqrufj/8UM8jDRedNo8of7qiC1KW5fBXiGaMPLyg2HAWBcBQEwlEQCEdBIBwFgXAUBMJREAhHQSAcBYFwFATCURAIR0EgHAWBcBQEwlEQCEdBIBwFgXAUBMJREAhHQW4UZ9oNBYFwFATCURAIR0EgHAWBcBQEwlEQCEdBIBwFgXAUBMJREAhHQSAcBYFwFATCURAIR0EgHAWBcBQEwu1a0F9TVqPuVdD7Z/36+hxargvXze9W0KldAXYOPjMAr5vfq6AqNb6r0qf66iVm1XNi9XcjfQwq5OFX/0rCmoh18zsW1CZRiGNn0KXKIPA8heh18/sT9H6q0qf8Gn5oSey6+d0JiryKRde7P0GR90HeKEf62zzvpPMOTAp3UEF6iA78sHFsQeWNEBqgDi6oNATuJY8uKLAgvBfuuIIiw1EQCDcxamTxKbVQ0FxlKWjBSvzhpgrylhfvi9QqZj8wKVxS1OHBFAROYSZBoWfN7VtQZC0UBALtVZAAQSO/dRLndfuu+E9lFYIyr9YLCnJLZJzdRJCgsercJmQKkg0KGnoaO91cQSKjb1sHr1DQt81wJ0EmKZrPtHkhg/3N9y6DzBFVGgwyyCnvZJCI9XY/X0wG+Uat+BbNxSyC3KZ6+pJ0tbiCrIp7fXZNgkS1LVViy9LHiRoTJAFB7RdpBYkjqFfKrniDgkTSBYnOkBFBIliQ9LraYoKiJ1DZ5yxdq2IEyZig7l2PIP1V6Y9G9QSZmnt9PIYkQQkTqLQg0YK6LqI19G0qa4/zbPOgIDG1mFSyBUknyP7T7zKCUqa/mNyRTpBOJekapXT7VafUSiLT4zqnveLSK9FTZQuSGwnyT6ByPndbkB5Y1KAxvbZaOo28QeO7N5VrTtkHWGPZQJBztZhVUFoG6Y/cNMkeLboWOCqsLtMN8la4YQlHkIzsvVUGJU2gMqOP3U41OHllf+KqJ0jsglZfDQpSpg63v3YHLCcoZQJVjCAVFGSp6UIqa1yxs7HrUKoXz1hVpssvKSg2nL7MmPboXaIH674gpa9KutX9i5F0IU30/rg2KsjcaOiT24ogZzzoC1JYkFK2IJObXkH9MontXlpQ/732u8799o1RQd39YydIDQWZCGKaL12iDQU5JxrdornoyehfUV1BXRkkSI20y84GjyCnxIYF6e9ihhcsSMUKsk9uBYLu/WuweO4kaCyDULVuBnWf9HBEHc8gZ7iJadOauljsKXRX5ChB7ou0K9Q6BKWfQr6g0cPjKp3nwIxwGbEzBfkORxXNeWBGuGxB7oUvMn5KfYcUlFHRjAdmhJssaP746WWXFJRfnoJyw1DQrGHmqGGdgpaHggAUBKAgwN0EbYY7CYoLCvZP2z21+LTD5wlKQdP2UxAFTdtPQRQ0bT8FUdC0/fsXtCcoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQYH5BhYDHUrvUyxhfekWHG2HO9eKR7OIhZhdUlGdUpJzVx2t59KV6GLEpOtwAddara7KLB5lbULOm7Awet2hzfa7WWF0ev5qiw40w76dKUHbxMHMLMs1NLFd+0KbocCNc9vL0eykou3iY2QV9qjLa98h7P+eyPbrocANVWY1BucUBcwtqunxyx6+WMJqiw41Q0aojVYIyiyPWIajQY3RGC6vlsxsSlJXWzRLYvD5SH7OhLpYzMLbPK8gbZS/tdJYvGxmkMy6tei31hOv0eTuX+fSbs+uzXmKef6d33s6NYp3zSefU9pGqjCk63AjT/KiRXTwEf1gFUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggBbEnT9vp7Icn0WmTZjI4UNCXo/1TN9iqe3cvNmhrYjqGj+Y04z6WfirKgENiOokJd6Ml0zr+52rEzQx5/P9Wyh0X/bUQsqHv85efYvwsoEnZ/+VtfPnv/aUQu6VB3t4/WgY1A7L/Wn+sW5nZ5pXDSCHmaYuprAugQ17X7/eXyYaQTVhzQTWG/BKgWdxlvfjkG1oJsN1esS1Khp02O8izWHHLWLqeLht3IE9vxvpcbKxcyJvgkrE6T+/UXkx9BVrL5jPO5lfn1QEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEGA/wFhL0CzqPy+VQAAAABJRU5ErkJggg==" /><!-- --></p>
<p>在第一个图中（<span class="math inline">\(\sigma\)</span> =
0.05），接受率很大，但在5000
次迭代中没有收敛到目标分布。在第二个图中（<span class="math inline">\(\sigma\)</span> =
0.5），链收敛得非常缓慢。在第三个图中（<span class="math inline">\(\sigma\)</span> =
2），链混合的效果比较好，约100步就收敛到目标分布。在第四个图中（<span class="math inline">\(\sigma\)</span> =
16），接受率非常小，因此第四条链收敛的效率很低。</p>
</div>
<div id="第三题-6" class="section level2">
<h2>第三题</h2>
<p><em>问题描述：</em>使用Gibbs sampler来生成二元正态链<span class="math inline">\(S_t =
(X_t,Y_t)\)</span>，随机变量具有0均值，单位标准差和0.9的相关性。丢弃适当的预烧样本后，绘制出生成的样本的图像。在生成的样本上拟合一个简单的线性回归模型<span class="math inline">\(Y=\beta_0+\beta_1X\)</span>，检查模型的残差的正态性、方差是否为常数。</p>
<p><em>思路：</em>Gibbs sampler的思想是从<span class="math inline">\(f(X_j|x_{(-j)})\)</span>中生成样本<span class="math inline">\(X_j\)</span>，在本题二维正态的条件下，计算条件分布的参数，然后生成样本即可。</p>
<p><em>解：</em>根据联合正态分布的条件分布的性质，有： <span class="math display">\[f(x|y)\sim
N(\mu_1+\dfrac{\rho\sigma_1}{\sigma_2}(y-\mu_2),(1-\rho^2)\sigma_1^2),\]</span>
<span class="math display">\[f(y|x)\sim
N(\mu_2+\dfrac{\rho\sigma_2}{\sigma_1}(x-\mu_1),(1-\rho^2)\sigma_2^2).\]</span>
按照如下流程生成<span class="math inline">\(T\)</span>个样本。在第<span class="math inline">\(t\)</span>次生成中：</p>
<p>（1）令<span class="math inline">\((x,y)=S(t-1)\)</span>;</p>
<p>（2）从<span class="math inline">\(f(X|y)\)</span>中生成<span class="math inline">\(X(t)\)</span>；</p>
<p>（3）更新<span class="math inline">\(x_1\)</span>为<span class="math inline">\(X(t)\)</span>；</p>
<p>（4）从<span class="math inline">\(f(Y|x)\)</span>中生成<span class="math inline">\(Y(t)\)</span>；</p>
<p>（5）令<span class="math inline">\(S(t)=(X(t),Y(t))\)</span>。</p>
<p>将<span class="math inline">\(\mu_1 =
\mu_2=0,~\sigma_1=\sigma_2=1,~\rho =
0.9\)</span>代入，生成5000个样本。丢弃1000个预烧样本后，绘制出生成的样本的图像。</p>
<div class="sourceCode" id="cb90"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb90-1"><a href="#cb90-1" tabindex="-1"></a><span class="co"># 定义参数</span></span>
<span id="cb90-2"><a href="#cb90-2" tabindex="-1"></a>N <span class="ot">=</span> <span class="dv">5000</span></span>
<span id="cb90-3"><a href="#cb90-3" tabindex="-1"></a>burn <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb90-4"><a href="#cb90-4" tabindex="-1"></a>S <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">0</span>, N, <span class="dv">2</span>)</span>
<span id="cb90-5"><a href="#cb90-5" tabindex="-1"></a>rho <span class="ot">=</span> <span class="fl">0.9</span></span>
<span id="cb90-6"><a href="#cb90-6" tabindex="-1"></a>mu1 <span class="ot">=</span> mu2 <span class="ot">=</span> <span class="dv">0</span></span>
<span id="cb90-7"><a href="#cb90-7" tabindex="-1"></a>sigma1 <span class="ot">=</span> sigma2 <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb90-8"><a href="#cb90-8" tabindex="-1"></a>k1 <span class="ot">=</span> <span class="fu">sqrt</span>(<span class="dv">1</span><span class="sc">-</span>rho<span class="sc">^</span><span class="dv">2</span>)<span class="sc">*</span>sigma1</span>
<span id="cb90-9"><a href="#cb90-9" tabindex="-1"></a>k2 <span class="ot">=</span> <span class="fu">sqrt</span>(<span class="dv">1</span><span class="sc">-</span>rho<span class="sc">^</span><span class="dv">2</span>)<span class="sc">*</span>sigma2</span>
<span id="cb90-10"><a href="#cb90-10" tabindex="-1"></a><span class="co"># 初始化</span></span>
<span id="cb90-11"><a href="#cb90-11" tabindex="-1"></a>S[<span class="dv">1</span>, ] <span class="ot">=</span> <span class="fu">c</span>(mu1, mu2)</span>
<span id="cb90-12"><a href="#cb90-12" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>N) {</span>
<span id="cb90-13"><a href="#cb90-13" tabindex="-1"></a>  y <span class="ot">=</span> S[i<span class="dv">-1</span>, <span class="dv">2</span>]</span>
<span id="cb90-14"><a href="#cb90-14" tabindex="-1"></a>  m1 <span class="ot">=</span> mu1 <span class="sc">+</span> rho <span class="sc">*</span> (y <span class="sc">-</span> mu2) <span class="sc">*</span> sigma1<span class="sc">/</span>sigma2</span>
<span id="cb90-15"><a href="#cb90-15" tabindex="-1"></a>  S[i, <span class="dv">1</span>] <span class="ot">=</span> <span class="fu">rnorm</span>(<span class="dv">1</span>, m1, k1)</span>
<span id="cb90-16"><a href="#cb90-16" tabindex="-1"></a>  x <span class="ot">=</span> S[i, <span class="dv">1</span>]</span>
<span id="cb90-17"><a href="#cb90-17" tabindex="-1"></a>  m2 <span class="ot">=</span> mu2 <span class="sc">+</span> rho <span class="sc">*</span> (x <span class="sc">-</span> mu1) <span class="sc">*</span> sigma2<span class="sc">/</span>sigma1</span>
<span id="cb90-18"><a href="#cb90-18" tabindex="-1"></a>  S[i, <span class="dv">2</span>] <span class="ot">=</span> <span class="fu">rnorm</span>(<span class="dv">1</span>, m2, k2)</span>
<span id="cb90-19"><a href="#cb90-19" tabindex="-1"></a>}</span>
<span id="cb90-20"><a href="#cb90-20" tabindex="-1"></a>s <span class="ot">=</span> S[(burn <span class="sc">+</span> <span class="dv">1</span>)<span class="sc">:</span>N, ]</span></code></pre></div>
<p><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAaVBMVEUAAAAAADoAAGYAOpAAZrY6AAA6ADo6AGY6Ojo6OpA6kNtmAABmADpmZmZmkJBmtrZmtv+QOgCQkGaQ2/+2ZgC2/7a2///bkDrbkJDb2//b/7bb/9vb///fU2v/tmb/25D//7b//9v///8ebJ3NAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAKZ0lEQVR4nO2diXqjNhRGNU3SJZm2SYfWXYKd8P4PWcQiJED8Wi62zPzn+6YlWL6gE7QghKIasom69QmUDgUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggCToI+X5+ak1MP7Dc+mQCZB1cP75emxqR5veDYFYgR9vLw2Z9X+++GvW55PcTiCqlbOiYIcrCL2+PHy8P7xwiLmYFfS6su3zzf6cRFu5tXdEC3o8+1ZQpBAjD3jxQd2KukrHvdG8eIDTwlF2vcDC2rr6J4sTwcWdOXj3ihefGAKCk/YFrKH9yqvLTuyoPOXbyfdk84ydGBBuh/UCsq8FzuwIN0P0oJwa39W7T1J7nEDKUjQeAVVWyNmlVLPl1/e/b3KAwsa6qCT2uhQa3lVd/WcPBqPLKjvKnoLTzPcjVx+1ClmBTH+HnDrlKwg6fEuT/3v0PmNn832Lv2gvoX7/KfZ9wqSEdRWlfpsL09Wq2zVDPt0FE0L5+0MFCSoGx91x7cyBXVFbPuhxqkvgWdvRZUvqK6lBOnBUafTcnma8pdSSXe5Pm1VQjHhUpET1Ar57cn5TWZdQeOA2WYzHx4uGS2oU9T/Zx4/apDwpNyaIEvQ+OW8YSEhQXW9LihuFPXzbTZ2k3kF9dWZr32KDBf3LetrtTbkExRH9fCv+4wmr5Lum8XzDnUQ6h21SuwfpAR1j0GdQpYuyAwn7jKiqLO7xVxQ3QnqvpUhSD9Hb4aO/8Du/aDEcHbDtCartndKCfp8637T+mGo2Wd13woV1Bee5efWJSQkqK2gh0ZHWdVQldMPGouZZBHrxbiCHEPdT7W9s+7JL2JRJxqQ8PNNYmZQrqC6tgU5lZMsV35w6OuLWIL6C+IWgvQdRoddX6f3pPMYww2m+ox3GTYqBhf9rju6goaBHqHjGkGqWRGkP10R1P1csKAnsUq6r3TGnI6C6lFQl++ZoLpv4QoWJDMzaBRUbwuqgwSpogRJzu4QElQXJUiykrYF1UDQmFDJCvp46aqK/n5j4GxdAretpI2H6f9T1j2CZqmyr6D+NtUeUXTKSEoRk7tZDRBUj4LasrWLoG5I2hk7zxQkgyVIOZmOFlTnCtLPM+wLyB6RLlDQzIJHkHIS5QlqL6E/XzyjQUUUMVeQxShIJQiax3IDu7SXjHN7KVPEMmcqpgiyPkKCNv0sBlJmj9GF6qC8l1ksQbOsLgXV8YLimA0fCwnauIQCBmZXBKl6BShIFStoawLVMIy5EsUd7jiyoO2XWeANW6agxbdkBVltWnortj2u6H8qb4dbzbJP0KpA4yk0H6snO3uEVZXVDwoVtElBN6uSxz2moM832Y5iiKDN4iUjaHVEOklQJfcyCxY05n9/QZsnGpMwcwa5E+6ggkRHFI8nSHhM+niCYBcnItwhBYkPdxxNkORxKQiEo6BFlI27+SyOImgWjoJAOEFBu3EQQXsQl+8poeAUvFsr2CZRkOAUPNg2JSEWNVGQ4L2YVE5m+RILlCZIeHaHPJlR7cf+SYLEZ3dIc3tBklPwXBSqP0Iyf2tBew53wGsqIPPq1oICKum0J6v1QQSFVNLeJ6vfg6CgSjrlyWodK2i9wsqt+gWKWMiAWdqT1ZVdvrOvixWUxfZwhxIWlKTqtoJm4WbnZgnytPd7CGp8PyYL6jpCAa+sblXnC0Hj+xrjbA3rA7WYLrWV/yRBiy+Zt42Snmp0E4vxs40QQeZ0ZoIme9M+nyD3SpzntZknXxc0S2beeExv5vFr4dGCho+UU9hcQWuzyUMFrRXJZimof1ctXVD4wgJY0Jh5R5D99ti6IGUyBwQ5b05BQUpGkOQVlCjInRMza/tcQU3jE6T2EhReB4WFG/N4RUF9Kd4WZN6ejc9RcCsWFi5A0KzQmFytJAgT5OiQFyRBjiBlfu1xgqwt3WM1gpRTW81eKC5D0LAx7Ro/WBXUeAWNn3oFmW8oZXQMx7M+zBC0w9odxxKkEV79JVbQkGBDUOOmXhU07t9BkPT6QXKCdF6du+Cmsb+8Jkh5BE2nt2dHcS3KxhNdLMhO6hFkEkQLahpL0Eq+YdbGjSusYWZbaabNNUFmR5qgZgdBV1gFz9YybUULsrc3BTlfa7IFhayjGBNuiaygcbRkLsgVYb7WuNJu3w9agYKkBJmcdDuiBfkOnClI8F0ND/GClHIrE+UIcvoS+wsSfFfDw5QZd3DfTuDmc9FtUK4gsybaFQRJvqvhIUzQZgjlEVhPIz3+A+cKCh0ISl7TfhI07ZgLAqtSzpf4moXePnCeoKDJC3lr2k89lTG1uiNBIe9qZK5pv8jFuPabN8Eyfo4gJxA60iJhwKNn/5r2YceFgjA+QduICAogd017AUFN0YJy17SXERSX3velBEEh86R9a9qHTWBfE3QVZAS1NfDpsbk8CT32CUp9T4J0qTnrP34k8+CwKIQEvTaXn/7q/m3znQrS2f74+o2CvAl1E1U9s4j5E1aPuiXD9/TfrSAJvgdBf5f0J/xkkBB0GnqIeK54ULiyEBCknzjre/WzUlnjZkcV1A0GtT2hk9z8oMKJnt3xrC39rHLf+Ml5D/m6xArSd2BVXvGaBxVLd5NkbvJBkMRrvTHncHeCJF6pizkHCpJJR0ElJnOTi81RjDuH+xEkDAUJBaUgmXTHE3QkKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEEBe0NY883FyjUmz3Ajn5A+SEM2HuCD9jNb7ZvDwxz1NmuVGOHq6jidIQjQv0oL6uTGe0e1zP6Br0iw3whmeda4FSYjmR1pQPwl0/Y+UndVzNwHdpFluRB5NC5KLtoq4oM2J+P0HJs1yI/JoelqyXLRVpAX1Rd9bAXRnbdIsN+KO1U1FkYrm4Z4F9Ytg35mg6xYxbeHOihioIIUraR3qzipp0MSexZr53kIb786aedBJO8t1FPVknU7FfXUUrTuANYaKwaRZboRTKdW/dSQSzQdvVgEUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCEBBAAoCUBCAggAUBKAgQHmCFrMOpKYhpEFBAAoCFCno4+X3l35qi57H8ocW1G7oGZt62pjM6vuhFCqodaKn+Oq/1HBWww+Xp+duxlTe36+KpVBBz9b0w2rY0c2+Ov/w59erlrhCBb12S/aYCXt9NdT5qrLXWYujaEEnI2hYuuc16G8TiFK0oNkVpPl8+1Vmem8oRQsaJjwPOzpOD/9trLW7A0UL6hov04r1tfWr1BT6QMoW5PaD9ILX3eToa1bT5QkqDAoCUBCAggAUBKAgAAUBKAhAQQAKAlAQgIIAFASgIAAFASgIQEEACgJQEICCABQEoCAABQEoCPA/aQFqS5dcjsgAAAAASUVORK5CYII=" /><!-- --></p>
<p>图像中，黑色代表样本<span class="math inline">\(X_t\)</span>，红色代表样本<span class="math inline">\(Y_t\)</span>。丢弃1000个预烧样本后，生成的链达到收敛状态。从两条链的重合度可以看出，二者相关系数很高，并且均值约为0.</p>
<p>线性回归模型残差性质的检验通过<code>lm</code>函数来实现。从残差散点图可以看出，残差的取值在0附近波动，没有呈现出异方差的特点，可以认为方差是常数。利用QQ图，可以认为残差满足正态性假定。
<img src="data:image/png;base64,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" /><!-- --><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAASAAAAEgCAMAAAAjXV6yAAAAw1BMVEUAAAAAADoAAGYAOjoAOmYAOpAAZmYAZpAAZrY6AAA6ADo6AGY6OgA6Ojo6OmY6OpA6ZpA6ZrY6kNtmAABmADpmOgBmOjpmZgBmZjpmkGZmkJBmkLZmkNtmtrZmtttmtv+QOgCQZjqQkGaQkLaQtpCQttuQ27aQ2/+2ZgC2Zjq2ZpC2kGa225C227a22/+2/7a2///bkDrbkGbbtmbbtpDb25Db27bb29vb/7bb/9vb////tmb/25D/27b//7b//9v////ul9uRAAAACXBIWXMAAA7DAAAOwwHHb6hkAAAM/ElEQVR4nO1diWLkRhF9NjvEhhBgnOUKWRsCeBbCsiKbJVhej/7/q6I+JXl0VF+qkicvsa3VtKpevylVd0utFpqfMAtwE5AOcBOQDnATkA5wE5AOcBOQDnATkA5wE5AOcBOQDnATkA5wE5AOcBOQDnATkA5wE5AOcBOQDnATkA5wE5AOcBOQDnATkA5wE5AOcBOQDnATkA5wE5AOcBOQDnATkA5wE5AOcBOQDnATkA5wE5AOcBOQDnATkA5wE5AOcBOQDpQzfQBu2z9PN7gKPvZ4h92D/8eH3wH41ZuHQYmTnRUMvnj37Hh7wD/fB9NoSgukSCYL9PTa1vzVu67AyE4nEC7uRwT69PpSoEAqhFIFajcduiqO7fQCtYeeCnSASIFaUk4gdUr87CvFusLF317j8t/tBx8+x8Wb5r/XeHWvy6i4+OJ+IFBb7wt1In24BvbO9tjOykjw6aYNIXe8d3oYCkwHEhRYgOa0dwJV7st1m7sfbuwX/rkjX4+cIu3WhRZPGepF1elOK5DS3wnUOZUp0OXvW05GoMdrRbPS33f7e/eu+V/7Qfuv71rib8wHba0+e1Al9z2BemfowakyvtMK9PGm/WuO7zsVeYpdfttW1lTG8tN/Kt+8tfTNb62Kwsd/tfF01RPIf2JCo5neeZqD+k5lCvS+/X7/cdOrsK6OrZNRzgdYW+PjX0wFZwRSYYfd97MCuVN04FSoQG31fq4UcOdErYJnSiDVNL365uPNQCCXwn6r6qtPWJO++juNPyvQxW9cP2jgVKhAhjUxgkywPA0FMvm43XnxB5hKt3/+P9xp/FXDbsA2IqjRFTrJQeMC6W/6eZI2LXrbzzNtYjO980SgLeQgE/gnrdhkBO0ePt0Nc5CRuOsjTO88FWjEaTAQXf9FGIFUVU76QdM56CRJNzZOdHr5yis0svNUoL7TWmQ/SBGq0etJ/1ltzbZir/5e+X6MhR2X/rHflR7ZOSJQz+nx7XAwRwXCD2HD8e2vH2g7MwIljb8EgJuAdICbgHSAm4B0gJuAdICbgHSAm4B0gJuAdICbgHSAm4B0gJuAdICbgHSAm4B0gJuAdICbgHSAm4B0gJuAdICbgHSAm4B0gJuAdICbgHSAm4B0IKDs0426AxV7B26jQEBZLVBlJmbeliIkDfBbqvpV//73CVQJK001U+xlAX7rsHt4vL5qDtNTUpVAj9daoPpsTjK4DRUaNW7nqn7eEaRqflCTd+YEMlMvXLo+C8BvHa6ebtQMrtlZ32pS130baWejzyBJ6/nF4bPiXzaQ2dxmUFigqUwVaW41oLHagH6Eh57SfYjKLuFfDAtaemga/0M7xm/VF/eVStJJ+ZfslwGw+miWIB/lNo53e927mWnmQ8xJg4luG+GIEUj1g5RAaX1kst810Tv9YXakRNAhqY9M9rsivDywIeR+aEf7LZODKkyP03uzt6cueJD9rgWjjf2d3ophfjr68W7p/CP7XQm95tX85z8gWwjyt9jRDjNXHP2O4bATgqlDTkyEeaxnzsAIc4Ux03fG6AFjNjJTymsuDXNDi+f/njaifxPSb4g5EZgfeI3smjCTjVAJc/GYix79OdlQLkZFzMViSZ4zF2gmN3dlyMb073aI6tPQ1nMQKPqccQTR9IkZrH5p+tDbHqyCqE+CQFGXOwiMVgFVnnCBDp3V7V4wo8uTEkFpIPstALo6zTkm6YDo0cXJdv2We2p9m0k6TJ4ogQ455iOQ/WZGqD5R16Rz3E4m+82KYHliL9qng+w3JyL0ibpon+OuPNlvRkTIE3fRfuFiYV6/+RClT9Qphk22YlHynE8/KC58mnMRKCY7u0PDC7pzbDunWLw8cR3F3UN15WaxxoLsNx0J4dPEdhRrNbtjI/fm0/SJ7Cg+/vK9/okH2W8ikKhPVEdxry95RAmUxDUCyfrE5CB1KfGw38Ipli5PXDN/0CuKpo3pyX5TfKTL86L7QVn0ebkC5ZHnxY7FcmQfaym24PxtscXLsmS/UcgmT8opNvO8WFO5e0KTT7OQ/cYgoz4JAs2EkOoqWUx1Bsh+w5FTnhSBZp8X8+O0KRnJfoORV594geaeF2OMoMzypLRicx1pP4l67RyUXZ9S/aBFFcPMEZFfnpfVUSyhT9RoXvlXD2Wm3EAk+6VbLKJPuEC2i1MRe9KrPXFYRp5wgeru9SYx9w+L1KEpFj5NsED+tmrvZUtl/dKslZInWCDfBax238kZrBbUJ1qghdHqmoPVkvLEn2JyBqtl9YlP0o+/mJ6quOJQo7A8Kc38zH3D9QarxfWJ7ijONmFrRVB5eUoNNVYZrJbr+wy8ZC+oscJgdR19tjtYXUeezQq0Uvg0WxVoNXm2KdB64dPECZSwflC439Mj15QnSiDe9YPWlSd2fhDb+kErh08Td1cjYf2gxMqtr09CBK2/fhCDPAk5aHa0mtFv7xAOfWJbsYX1gzL69QewyLOdfhCTPFsRiCt8mo0IxCdPxEX7julq/SBOfbYQQZzybEAg1vBpEpr5xKXYiX655YntKLa/q7SOEMkvY+PVcQgueLwzXejiQw0J8kQNVldaP0iGPgkRVPhpHyH6ROUgPUwtPFgVIk/c9aAcfcUFv1LkWb0fRKu2/lyEPDI7imKiRwHhBUs/Ny9Kn6hWLMf7jKb9ytIn8qJ9Qb/C9Im8aL8Awiv8pvwKkycqB81NvjMgvMJvwq84faIEul5K0oQXsE34hWvhqbSKA8EFCUt0EV7hN+5XXPwUStKxESRQn1JJWtVy9hV+Y34l6lMmSTfLr/Dr++1lZv1DpbQKEFww+8IC6MeOtAASMBaD+r8bnJ6bQMsP1KE/ehfVwmsgvGDmwSpsBDUS4ydKoNyLvPWjR5w+UUk6YZG3kUSDkX2CgOCCGRd5k9eonwLBBZMWeRuYgz69hAPhBZcXeaO9ws//LxqIKLi8yBvpFX4m6ZAJMAHZC2pQXuGHCLvrA9kLGiy+ws/m50Cz6wOhBR+v9/pqao5ZrkJb9gEQWFD3D1V4bGc14DQgsKB+Wl6/WWPuuXmDuStH2AzCBNIXwEwGXp7+kraAztBx5qIBRsNM6gup9q7OTwKNmNQCmfSzPBY7R4F05tHTEwk3N85SoPri/ulGxU6WVyAFOM5bNMBoqMlazwB+vM4xgyHIcdaiAUYZTWZ3TC8aYJTRZHbH9KIBRhlNZndMLxpglNHkywK4CUgHuAlIB7gJSAe4CUgHuAlIB7gJSAe4CUgHuAlIB7gJSAe4CUgHuAlIB7gJSAeY/OqlYymXbsk3M8kWw4DsFkk43rW1pqyfr57mrykKkS0GArkN0mDvoBBvMS3fzKRbDAUy2wvCcmiEVpsUbEFAZntBWL6FYqb/0xc7yH9TBpnthWD6iYauiI4IclwQLIYCuQ3SURNzNF0gisVQILtFKkjfdtApViB+OASqTHelItUmJEnTLIYCBWxSQFwjhN7Mp646MgWUMLoMPeOPAnJHkWwxEChidRGVmeZFqHlFHGrQLYYBme29OICbgHSAm4B0gJuAdICbgHSAm4B0gJuAdICbgHSAm4B0gJuAdICbgHSAm4B0gJuAdICbgHSAm4B0gJuAdICbgHSAm4B0gJuAdICbgHSAm4B0gJuAdICbgHSAm4B0gJuAdICbgHSAm4B0oJjlbnHY/1CXy69vx1dt7nbWy7ffrZE8a/SXjiAz/4nKdbKc+8CsoTY/j8OVPUuB7ESq2UWgtinQn65hX61kJ8PXZuPpy7+qZffMbrWo/u6HG1dOL/kEfZytrF/mW6/X5/b7Ml+35/StN6I/c/70ev1xgiFZhDk4gdQkePtjF0tTNVDVVGuFuN0+dagdSg23Jo0VyC8JXl++9wJ1ZYwDZ0S/3Nsa9guQRQC5tBiFE2ivzwu/gpOZWKdXnNn3Fnbq6mYiRb8TTlXOCuRnmtVGB7W/V8Y58QJ5wykvlUNK/RfRy0HtL1PBthImidjaNH63q1s/x9TArEDDMloVL1DPcLEXgiXimUC23bcC2do0frcXyJ1KbQq5/LaLoNFTbFDmmUDOsHkSSHIO6kdQ45qhYQTZcv0I0n97p1iXpHcPzuawzFgEORzipi8i5iAyhgL5lreXg257DfLzHKRTR92dYrqZP97tvtcJ3aScYZmhQMOWPrLdR1zNiRgKZFZJO+j3TrhWTDfqdrd/sYnacby7MoGBfVe3g1ZIrZWl3vbVbt0Oy9jM3G/FlGEdSpEPAiGbGGN4JpDul+h86fpB9j0vdvfhWT9ITwE+2EDTsGmlLaxGMl+bHNSV0e3+s36QCbHoCcLIocPqeJt7NvQ0sJqnjQLcBKQD3ASkA9wEpAPcBKQD3ASkA9wEpAPcBKQD3ASkA9wEpAPcBKQD3ASkA9wEpAPcBKQD3ASkA9wEpAPcBKQD3ASkA9wEpAPcBKQD3ASkA9wEpAPcBKTjRzQGIdEqD7pjAAAAAElFTkSuQmCC" /><!-- --></p>
</div>
<div id="第四题-2" class="section level2">
<h2>第四题</h2>
<p><em>问题描述：</em>根据例9.1，使用Gelman-Rubin方法来监测链的收敛性，并且继续生成链，直到在<span class="math inline">\(\hat
R&lt;1.2\)</span>的准则下近似收敛到目标分布。同样地，使用coda包，通过Gelman-Rubin方法监测链的收敛性。</p>
<p><em>思路：</em>Gelman-Rubin方法通过比较多个独立运行的MCMC链的方差来检查链是否已经收敛到了目标分布。指定参数值和链的条数，计算Gelman-Rubin统计量，并和1.2的阈值进行比较，判断是否收敛。</p>
<p><em>解：</em>使用Metropolis-Hastings方法从Rayleigh分布中生成样本。Rayleigh分布的密度函数为：
<span class="math display">\[f(x)=\dfrac
x{\sigma^2}e^{-x^2/(2\sigma^2)},\quad x\geq 0, \sigma&gt;0.\]</span>
生成的流程及函数如下：</p>
<p>（1）指定提议分布<span class="math inline">\(g(\cdot|X)\)</span>
为<span class="math inline">\(\chi^2(X)\)</span>；</p>
<p>（2）从<span class="math inline">\(\chi^2(1)\)</span>中生成<span class="math inline">\(X_1\)</span>；</p>
<p>（3）重复<span class="math inline">\(i=2,\ldots,N\)</span>：</p>
<ol style="list-style-type: lower-alpha">
<li><p>从<span class="math inline">\(\chi^2(X_{i-1})\)</span>中生成<span class="math inline">\(Y\)</span>；</p></li>
<li><p>从<span class="math inline">\(U(0,1)\)</span>中生成<span class="math inline">\(U\)</span>；</p></li>
<li><p>计算<span class="math inline">\(\alpha(X_{i-1},Y)=\frac{f(Y)g(X_{i-1}|Y)}{f(X_{i-1})g(Y|X_{i-1})}\)</span>。若<span class="math inline">\(U\leq \alpha(X_{i-1},Y)\)</span>则 接受<span class="math inline">\(Y\)</span>并令<span class="math inline">\(X_i=Y\)</span>，否则令<span class="math inline">\(X_{i}=X_{i-1}\)</span>。</p></li>
</ol>
<div class="sourceCode" id="cb91"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb91-1"><a href="#cb91-1" tabindex="-1"></a><span class="co"># Rayleigh function returns pdf</span></span>
<span id="cb91-2"><a href="#cb91-2" tabindex="-1"></a>Rayleigh <span class="ot">=</span> <span class="cf">function</span>(x, sigma) {</span>
<span id="cb91-3"><a href="#cb91-3" tabindex="-1"></a>  <span class="cf">if</span> (<span class="fu">any</span>(x <span class="sc">&lt;</span> <span class="dv">0</span>)) <span class="fu">return</span> (<span class="dv">0</span>)</span>
<span id="cb91-4"><a href="#cb91-4" tabindex="-1"></a>  <span class="fu">stopifnot</span>(sigma <span class="sc">&gt;</span> <span class="dv">0</span>)</span>
<span id="cb91-5"><a href="#cb91-5" tabindex="-1"></a>  <span class="fu">return</span>((x <span class="sc">/</span> sigma<span class="sc">^</span><span class="dv">2</span>) <span class="sc">*</span> <span class="fu">exp</span>(<span class="sc">-</span>x<span class="sc">^</span><span class="dv">2</span> <span class="sc">/</span> (<span class="dv">2</span><span class="sc">*</span>sigma<span class="sc">^</span><span class="dv">2</span>)))</span>
<span id="cb91-6"><a href="#cb91-6" tabindex="-1"></a>}</span>
<span id="cb91-7"><a href="#cb91-7" tabindex="-1"></a><span class="co"># Rchain function generates chain for Rayleigh dist</span></span>
<span id="cb91-8"><a href="#cb91-8" tabindex="-1"></a>Rchain <span class="ot">=</span> <span class="cf">function</span>(sigma, N, X1) {</span>
<span id="cb91-9"><a href="#cb91-9" tabindex="-1"></a>  x <span class="ot">=</span> <span class="fu">rep</span>(<span class="dv">0</span>, N)</span>
<span id="cb91-10"><a href="#cb91-10" tabindex="-1"></a>  x[<span class="dv">1</span>] <span class="ot">=</span> X1</span>
<span id="cb91-11"><a href="#cb91-11" tabindex="-1"></a>  u <span class="ot">=</span> <span class="fu">runif</span>(N)</span>
<span id="cb91-12"><a href="#cb91-12" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>N) {</span>
<span id="cb91-13"><a href="#cb91-13" tabindex="-1"></a>    xt <span class="ot">=</span> x[i<span class="dv">-1</span>]</span>
<span id="cb91-14"><a href="#cb91-14" tabindex="-1"></a>    y <span class="ot">=</span> <span class="fu">rchisq</span>(<span class="dv">1</span>, <span class="at">df =</span> xt)</span>
<span id="cb91-15"><a href="#cb91-15" tabindex="-1"></a>    r1 <span class="ot">=</span> <span class="fu">Rayleigh</span>(y, sigma) <span class="sc">*</span> <span class="fu">dchisq</span>(xt, <span class="at">df =</span> y)</span>
<span id="cb91-16"><a href="#cb91-16" tabindex="-1"></a>    r2 <span class="ot">=</span> <span class="fu">Rayleigh</span>(xt, sigma) <span class="sc">*</span> <span class="fu">dchisq</span>(y, <span class="at">df =</span> xt)</span>
<span id="cb91-17"><a href="#cb91-17" tabindex="-1"></a>    <span class="cf">if</span> (u[i] <span class="sc">&lt;=</span> r1<span class="sc">/</span>r2){</span>
<span id="cb91-18"><a href="#cb91-18" tabindex="-1"></a>      x[i] <span class="ot">=</span> y</span>
<span id="cb91-19"><a href="#cb91-19" tabindex="-1"></a>    }<span class="cf">else</span>{</span>
<span id="cb91-20"><a href="#cb91-20" tabindex="-1"></a>      x[i] <span class="ot">=</span> xt</span>
<span id="cb91-21"><a href="#cb91-21" tabindex="-1"></a>    }</span>
<span id="cb91-22"><a href="#cb91-22" tabindex="-1"></a>  }</span>
<span id="cb91-23"><a href="#cb91-23" tabindex="-1"></a>  <span class="fu">return</span>(x)</span>
<span id="cb91-24"><a href="#cb91-24" tabindex="-1"></a>}</span></code></pre></div>
<p>在Gelman-Rubin方法中，scalar summary statistic <span class="math inline">\(\psi_{ij}\)</span> 是时刻<span class="math inline">\(i\)</span>下第<span class="math inline">\(j\)</span>条链的均值。Gelman-Rubin统计量<span class="math inline">\(\hat R\)</span>的计算公式如下： <span class="math display">\[\hat R = \dfrac{\hat Var(\psi)}{W},\]</span>
其中，<span class="math inline">\(\hat Var(\psi) =
\dfrac{n-1}{n}W+\dfrac{1}{n}B\)</span>，<span class="math inline">\(W\)</span>为<span class="math inline">\(\psi_{ij}\)</span>的组内方差，<span class="math inline">\(B\)</span>为<span class="math inline">\(\psi_{ij}\)</span>的组间方差。实现Gelman-Rubin方法的函数如下：</p>
<div class="sourceCode" id="cb92"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb92-1"><a href="#cb92-1" tabindex="-1"></a><span class="co"># 函数Gelman.Rubin以psi作为输入</span></span>
<span id="cb92-2"><a href="#cb92-2" tabindex="-1"></a>Gelman.Rubin <span class="ot">=</span> <span class="cf">function</span>(psi) {</span>
<span id="cb92-3"><a href="#cb92-3" tabindex="-1"></a>  psi <span class="ot">=</span> <span class="fu">as.matrix</span>(psi)</span>
<span id="cb92-4"><a href="#cb92-4" tabindex="-1"></a>  n <span class="ot">=</span> <span class="fu">ncol</span>(psi)</span>
<span id="cb92-5"><a href="#cb92-5" tabindex="-1"></a>  k <span class="ot">=</span> <span class="fu">nrow</span>(psi)</span>
<span id="cb92-6"><a href="#cb92-6" tabindex="-1"></a>  B <span class="ot">=</span> n <span class="sc">*</span> <span class="fu">var</span>(<span class="fu">rowMeans</span>(psi))</span>
<span id="cb92-7"><a href="#cb92-7" tabindex="-1"></a>  W <span class="ot">=</span> <span class="fu">mean</span>(<span class="fu">apply</span>(psi, <span class="dv">1</span>, <span class="st">&quot;var&quot;</span>))</span>
<span id="cb92-8"><a href="#cb92-8" tabindex="-1"></a>  v.hat <span class="ot">=</span> W<span class="sc">*</span>(n<span class="dv">-1</span>)<span class="sc">/</span>n <span class="sc">+</span> B<span class="sc">/</span>n</span>
<span id="cb92-9"><a href="#cb92-9" tabindex="-1"></a>  r.hat <span class="ot">=</span> v.hat <span class="sc">/</span> W</span>
<span id="cb92-10"><a href="#cb92-10" tabindex="-1"></a>  <span class="fu">return</span>(r.hat)</span>
<span id="cb92-11"><a href="#cb92-11" tabindex="-1"></a>}</span></code></pre></div>
<p>与例9.1一致，我们在<span class="math inline">\(\sigma^2=16\)</span>的条件下，生成4条链，每一条链指定不同的初始值。生成20000个样本并将前1000个作为预烧样本丢弃。</p>
<div class="sourceCode" id="cb93"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb93-1"><a href="#cb93-1" tabindex="-1"></a><span class="co"># 参数</span></span>
<span id="cb93-2"><a href="#cb93-2" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">7</span>)</span>
<span id="cb93-3"><a href="#cb93-3" tabindex="-1"></a>sigma <span class="ot">=</span> <span class="dv">4</span></span>
<span id="cb93-4"><a href="#cb93-4" tabindex="-1"></a>burn <span class="ot">=</span> <span class="dv">1000</span></span>
<span id="cb93-5"><a href="#cb93-5" tabindex="-1"></a>chain.len <span class="ot">=</span> <span class="dv">20000</span></span>
<span id="cb93-6"><a href="#cb93-6" tabindex="-1"></a>chain.num <span class="ot">=</span> <span class="dv">4</span></span>
<span id="cb93-7"><a href="#cb93-7" tabindex="-1"></a><span class="co"># x0 = rchisq(4, df=1)</span></span>
<span id="cb93-8"><a href="#cb93-8" tabindex="-1"></a>x0 <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">6</span>, <span class="dv">10</span>, <span class="dv">14</span>)   <span class="co"># initial values</span></span>
<span id="cb93-9"><a href="#cb93-9" tabindex="-1"></a><span class="co"># 生成四条不同初始值的链</span></span>
<span id="cb93-10"><a href="#cb93-10" tabindex="-1"></a>MCMC.chain <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">0</span>, <span class="at">nrow =</span> chain.num, <span class="at">ncol =</span> chain.len)</span>
<span id="cb93-11"><a href="#cb93-11" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>chain.num){</span>
<span id="cb93-12"><a href="#cb93-12" tabindex="-1"></a>  MCMC.chain[i, ] <span class="ot">=</span> <span class="fu">Rchain</span>(sigma, chain.len, x0[i])</span>
<span id="cb93-13"><a href="#cb93-13" tabindex="-1"></a>}</span>
<span id="cb93-14"><a href="#cb93-14" tabindex="-1"></a></span>
<span id="cb93-15"><a href="#cb93-15" tabindex="-1"></a>psi0 <span class="ot">=</span> <span class="fu">t</span>(<span class="fu">apply</span>(MCMC.chain, <span class="dv">1</span>, cumsum))</span>
<span id="cb93-16"><a href="#cb93-16" tabindex="-1"></a>psi <span class="ot">=</span> psi0</span>
<span id="cb93-17"><a href="#cb93-17" tabindex="-1"></a><span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span><span class="fu">nrow</span>(psi0)){</span>
<span id="cb93-18"><a href="#cb93-18" tabindex="-1"></a>  psi[i,] <span class="ot">=</span> psi0[i,] <span class="sc">/</span> (<span class="dv">1</span><span class="sc">:</span><span class="fu">ncol</span>(psi0))</span>
<span id="cb93-19"><a href="#cb93-19" tabindex="-1"></a>}</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --><img src="data:image/png;base64,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" /><!-- --></p>
<p>4条链在<span class="math inline">\(\hat
R&lt;1.2\)</span>的准则下均收敛到目标分布。需要说明的是，Metropolis-Hastings方法使用卡方分布生成初始值，但由于该方法有随机性，可能生成较为接近的初始值，因此本题的解答中，人为给定了四个差别较大的初始值，以凸显链的生成过程的差别。</p>
<p>接下来，使用coda包实现上述过程。以<code>obj</code>作为mcmc变量，输入到函数<code>gelman.plot</code>中，图片展示的是
Gelman-Rubin
收缩因子随着迭代次数的增加而演变的规律。由图像可知，MCMC链的收敛效果较好，这一结论与第一问的结论一致。</p>
<pre><code>## Warning: package &#39;coda&#39; was built under R version 4.3.2</code></pre>
<div class="sourceCode" id="cb95"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb95-1"><a href="#cb95-1" tabindex="-1"></a>obj <span class="ot">=</span> <span class="fu">mcmc.list</span>(<span class="fu">mcmc</span>(MCMC.chain[<span class="dv">1</span>, ]), <span class="fu">mcmc</span>(MCMC.chain[<span class="dv">2</span>, ]), </span>
<span id="cb95-2"><a href="#cb95-2" tabindex="-1"></a>                 <span class="fu">mcmc</span>(MCMC.chain[<span class="dv">3</span>, ]), <span class="fu">mcmc</span>(MCMC.chain[<span class="dv">4</span>, ]))</span>
<span id="cb95-3"><a href="#cb95-3" tabindex="-1"></a><span class="fu">gelman.diag</span>(obj)</span></code></pre></div>
<pre><code>## Potential scale reduction factors:
## 
##      Point est. Upper C.I.
## [1,]          1          1</code></pre>
<div class="sourceCode" id="cb97"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb97-1"><a href="#cb97-1" tabindex="-1"></a><span class="fu">gelman.plot</span>(obj)</span></code></pre></div>
<p><img src="data:image/png;base64,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" /><!-- --></p>
</div>
</div>
<div id="hw8" class="section level1">
<h1>HW8</h1>
<div id="第一题-7" class="section level2">
<h2>第一题</h2>
<p><em>问题描述：</em>设<span class="math inline">\(X_1,...,X_n\sim^{iid}~Exp(\lambda)\)</span>。由于某种原因，只知道<span class="math inline">\(X_i\)</span>落在某个区间<span class="math inline">\((u_i,v_i)\)</span>，其中<span class="math inline">\(u_i&lt;v_i\)</span>是两个非随机的已知常数。这种数据成为区间删失数据。</p>
<p>（1）试分别直接极大化观测数据的似然函数与采用EM算法求解<span class="math inline">\(\lambda\)</span>的MLE。证明EM算法收敛于观测数据的MLE，且收敛有线性速度。</p>
<p>（2）设<span class="math inline">\((u_i,v_i),~i=1,...n(=10)\)</span>的观测值为<span class="math inline">\((11,12),~(8,9),...\)</span>（略）。试分别编程实现上述两种算法以得到<span class="math inline">\(\lambda\)</span>的MLE的数值解。</p>
<p><em>思路：</em>根据区间删失数据的似然函数，首先极大化似然函数，求解MLE；然后再写出完全数据的似然函数，用EM算法求解<span class="math inline">\(\lambda\)</span>。将MLE与EM算法求出的两式进行对比，找到二者之间的关系并利用它证明线性收敛。</p>
<p><em>解：</em>（1）由于<span class="math inline">\(Exp(\lambda)\)</span>的分布函数为<span class="math inline">\(F(x) = 1-e^{-\lambda
x}\)</span>，因此区间删失数据的对数似然函数为： <span class="math display">\[l_o(\lambda) =
\ln[\prod_{i=1}^nP_{\lambda}(u_i\leq X_i\leq v_i)]\]</span> <span class="math display">\[= \sum_{i=1}^n\ln(e^{-\lambda u_i}-e^{-\lambda
v_i}).\]</span> 令上式对<span class="math inline">\(\lambda\)</span>的偏导为0，即<span class="math inline">\(\frac{\partial l_o(\lambda)}{\partial
\lambda}=0\)</span>，解得： <span class="math display">\[\sum_{i=1}^n\dfrac{-u_ie^{-\lambda
(u_i-v_i)}+v_i}{e^{-\lambda (u_i-v_i)}-1}=0.\]</span> <span class="math inline">\(\lambda\)</span>的MLE为上式的数值解（无法求出解析解）。</p>
<p>EM算法中，我们首先给出完全数据的似然函数： <span class="math display">\[l_c(\lambda) =
\ln[\prod_{i=1}^nf_{\lambda}(X_i)]\]</span> <span class="math display">\[ = n\ln\lambda -\sum_{i=1}^n\lambda X_i.\]</span>
E-Step：第<span class="math inline">\(j+1\)</span>步的时候，以观测到的数据<span class="math inline">\(u_i,v_i\)</span>和第<span class="math inline">\(j\)</span>步求出的<span class="math inline">\(\hat\lambda^{(j)}\)</span>作为条件，计算完全数据的似然函数的期望。
<span class="math display">\[Q(\lambda|\hat\lambda^{(j)})=E_{X|u_i, v_i,
\hat\lambda^{(j)}}[l_c(\lambda)]\]</span> <span class="math display">\[=n\ln\lambda-\lambda\sum_{i=1}^n E[x_i|u_i, v_i,
\hat\lambda^{(j)}]\]</span> 其中，<span class="math inline">\(E[x_i|u_i,
v_i,
\hat\lambda^{(j)}]\)</span>的求解如下（事实上，在线性收敛性的证明过程中我们发现，积分式还可以进一步化简）：
<span class="math display">\[E[x_i|u_i, v_i, \hat\lambda^{(j)}] =
\int_{u_i}^{v_i}\dfrac{x\hat\lambda^{(j)}e^{-\hat\lambda^{(j)}x}}{e^{-\hat\lambda^{(j)}u_i}-e^{-\hat\lambda^{(j)}v_i}}dx.\]</span></p>
<p>M-Step：对<span class="math inline">\(Q(\lambda|\hat\lambda^{(j)})\)</span>求导，并令导数为0：
<span class="math display">\[\dfrac{\partial
Q(\lambda|\hat\lambda^{(j)})}{\partial \lambda} = \dfrac{n}{\lambda} -
\sum_{i=1}^nE[x_i|u_i, v_i, \hat\lambda^{(j)}].\]</span></p>
<p><span class="math inline">\(\hat\lambda^{(j+1)}\)</span>即导数为0时的解：
<span class="math display">\[\hat\lambda^{(j+1)} =
\dfrac{n}{\sum_{i=1}^nE[x_i|u_i, v_i, \hat\lambda^{(j)}]}.\]</span></p>
<p>下面证明EM算法收敛于观测数据的MLE，且收敛有线性速度：</p>
<p>将EM算法的迭代式进行化简，有<span class="math inline">\(\hat\lambda^{(j+1)} =
f(\hat\lambda^{(j)})\)</span>的关系式，且该式与MLE方法中<span class="math inline">\(\hat\lambda_{MLE}\)</span>的表达式有关： <span class="math display">\[\hat\lambda^{(j+1)} =
\dfrac{n}{\sum_{i=1}^n\int_{u_i}^{v_i}\dfrac{x\hat\lambda^{(j)}e^{-\hat\lambda^{(j)}x}}{e^{-\hat\lambda^{(j)}u_i}-e^{-\hat\lambda^{(j)}v_i}}dx}\]</span>
<span class="math display">\[ = \dfrac{1}{\dfrac{1}{n}\sum_{i=1}^n
\dfrac{u_ie^{-\hat\lambda^{(j)}u_i}-v_ie^{-\hat\lambda^{(j)}v_i}}{e^{-\hat\lambda^{(j)}u_i}-e^{-\hat\lambda^{(j)}v_i}}+\dfrac{1}{\hat\lambda^{(j)}}}\triangleq
f(\hat\lambda^{(j)}).\]</span></p>
<p>由于<span class="math inline">\(\hat\lambda_{MLE}\)</span>使得分母中的<span class="math inline">\(\sum_{i=1}^n
\dfrac{u_ie^{-\hat\lambda^{(j)}u_i}-v_ie^{-\hat\lambda^{(j)}v_i}}{e^{-\hat\lambda^{(j)}u_i}-e^{-\hat\lambda^{(j)}v_i}}\)</span>为0，因此有：<span class="math inline">\(\hat\lambda_{MLE}=f(\hat\lambda_{MLE}).\)</span></p>
<p>接下来，对<span class="math inline">\(f(\lambda)\)</span>求导，为简化记号，记<span class="math inline">\(m(\lambda)=\sum_{i=1}^n \dfrac{u_ie^{-\lambda
u_i}-v_ie^{-\lambda v_i}}{e^{-\lambda u_i}-e^{-\lambda v_i}}\)</span>：
<span class="math display">\[f&#39;(\lambda) =
-\dfrac{1}{(\dfrac{1}{n}m(\lambda)+\dfrac{1}{\lambda})^2}(\dfrac{1}{n}m&#39;(\lambda)-\dfrac{1}{\lambda^2}).\]</span>
将<span class="math inline">\(\hat\lambda_{MLE}\)</span>代入并化简：
<span class="math display">\[f&#39;(\hat\lambda_{MLE}) =
1-\dfrac{\lambda^2}{n}m&#39;(\hat\lambda_{MLE}),\]</span> <span class="math display">\[ = 1-\dfrac{1}{n}\sum_{i=1}^n
\dfrac{\lambda^2(u_i-v_i)^2}{e^{\lambda(u_i-v_i)}+e^{-\lambda(u_i-v_i)}-2}\]</span>
利用<span class="math inline">\(e^x=1+x+\dfrac{x^2}{2}+o(x^2)\)</span>，<span class="math inline">\(e^{-x}=1-x+\dfrac{x^2}{2}+o(x^2)\)</span>，对上式第二项的分母进行Taylor展开：
<span class="math display">\[e^{\lambda(u_i-v_i)}+e^{-\lambda(u_i-v_i)}-2=(1+\lambda(u_i-v_i)+\dfrac{\lambda^2(u_i-v_i)^2}{2}+o(\lambda^2(u_i-v_i)^2)\]</span>
<span class="math display">\[+
(1-\lambda(u_i-v_i)+\dfrac{\lambda^2(u_i-v_i)^2}{2}+o(\lambda^2(u_i-v_i)^2)-2\]</span>
<span class="math display">\[= \lambda^2(u_i-v_i)^2 +
o(\lambda^2(u_i-v_i)^2).\]</span> 因此有<span class="math inline">\(0&lt;f&#39;(\hat\lambda_{MLE})&lt;1\)</span>。</p>
<p>又由于<span class="math inline">\(f&#39;&#39;(\hat\lambda_{MLE})\)</span>存在连续，因此<span class="math inline">\(\forall~0&lt;k&lt;1,~\exists~\sigma&gt;0\)</span>，使得<span class="math inline">\(\lambda\in(\hat\lambda_{MLE}-\sigma,\hat\lambda_{MLE}+\sigma)\)</span>内有<span class="math inline">\(|f&#39;(\lambda)|&lt;k\)</span>，进而对<span class="math inline">\(a,b\in(\hat\lambda_{MLE}-\sigma,\hat\lambda_{MLE}+\sigma)\)</span>，有：
<span class="math display">\[|f(a)-f(b)|=|f&#39;(c)||a-b|&lt;
k|a-b|,~c\in(a,b),\]</span> 由不动点引理，在<span class="math inline">\((\hat\lambda_{MLE}-\sigma,\hat\lambda_{MLE}+\sigma)\)</span>内存在<span class="math inline">\(f(\lambda)\)</span>唯一的不动点，而之前已解得<span class="math inline">\(\hat\lambda_{MLE}=f(\hat\lambda_{MLE})\)</span>，
即<span class="math inline">\(\hat\lambda_{MLE}\)</span>是<span class="math inline">\(f(\cdot)\)</span>的不动点。</p>
<p>再由<span class="math inline">\(0&lt;f&#39;(\hat\lambda_{MLE})&lt;1\)</span>的结论知，EM算法以线性速度收敛于MLE。</p>
<p>（2）给定<span class="math inline">\((u_i,v_i),~i=1,...n(=10)\)</span>的观测值的情况下。我们首先极大化似然函数得到<span class="math inline">\(\lambda\)</span>的MLE的数值解。</p>
<div class="sourceCode" id="cb98"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb98-1"><a href="#cb98-1" tabindex="-1"></a>ui <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">11</span>, <span class="dv">8</span>, <span class="dv">27</span>, <span class="dv">13</span>, <span class="dv">16</span>, <span class="dv">0</span>, <span class="dv">23</span>, <span class="dv">10</span>, <span class="dv">24</span>, <span class="dv">2</span>)</span>
<span id="cb98-2"><a href="#cb98-2" tabindex="-1"></a>vi <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">12</span>, <span class="dv">9</span>, <span class="dv">28</span>, <span class="dv">14</span>, <span class="dv">17</span>, <span class="dv">1</span>, <span class="dv">24</span>, <span class="dv">11</span>, <span class="dv">25</span>, <span class="dv">3</span>)</span>
<span id="cb98-3"><a href="#cb98-3" tabindex="-1"></a>partial.l <span class="ot">=</span> <span class="cf">function</span>(lambda){</span>
<span id="cb98-4"><a href="#cb98-4" tabindex="-1"></a>  equation <span class="ot">=</span> (<span class="sc">-</span>ui<span class="sc">*</span><span class="fu">exp</span>(<span class="sc">-</span>lambda<span class="sc">*</span>(ui<span class="sc">-</span>vi))<span class="sc">+</span>vi) <span class="sc">/</span> (<span class="fu">exp</span>(<span class="sc">-</span>lambda<span class="sc">*</span>(ui<span class="sc">-</span>vi))<span class="sc">-</span><span class="dv">1</span>)</span>
<span id="cb98-5"><a href="#cb98-5" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">sum</span>(equation))</span>
<span id="cb98-6"><a href="#cb98-6" tabindex="-1"></a>}</span>
<span id="cb98-7"><a href="#cb98-7" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;Lambda estimated by MLE:&quot;</span>, <span class="fu">uniroot</span>(partial.l, <span class="at">lower =</span> <span class="fl">0.01</span>, <span class="at">upper =</span> <span class="dv">3</span>)<span class="sc">$</span>root)</span></code></pre></div>
<pre><code>## Lambda estimated by MLE: 0.07194754</code></pre>
<p>然后根据EM算法求解<span class="math inline">\(\lambda\)</span>。</p>
<div class="sourceCode" id="cb100"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb100-1"><a href="#cb100-1" tabindex="-1"></a><span class="co"># E-Step 的条件期望的被积函数</span></span>
<span id="cb100-2"><a href="#cb100-2" tabindex="-1"></a>integrand <span class="ot">=</span> <span class="cf">function</span>(x, lambda, uk, vk) {</span>
<span id="cb100-3"><a href="#cb100-3" tabindex="-1"></a>  numerator <span class="ot">=</span> x <span class="sc">*</span> lambda <span class="sc">*</span> <span class="fu">exp</span>(<span class="sc">-</span>lambda <span class="sc">*</span> x)</span>
<span id="cb100-4"><a href="#cb100-4" tabindex="-1"></a>  denominator <span class="ot">=</span> <span class="fu">exp</span>(<span class="sc">-</span>lambda <span class="sc">*</span> uk) <span class="sc">-</span> <span class="fu">exp</span>(<span class="sc">-</span>lambda <span class="sc">*</span> vk)</span>
<span id="cb100-5"><a href="#cb100-5" tabindex="-1"></a>  <span class="fu">return</span>(numerator <span class="sc">/</span> denominator)</span>
<span id="cb100-6"><a href="#cb100-6" tabindex="-1"></a>}</span>
<span id="cb100-7"><a href="#cb100-7" tabindex="-1"></a></span>
<span id="cb100-8"><a href="#cb100-8" tabindex="-1"></a><span class="co"># EM算法</span></span>
<span id="cb100-9"><a href="#cb100-9" tabindex="-1"></a>em_algorithm <span class="ot">=</span> <span class="cf">function</span>(lambda_initial, num_iterations, eps, u, v) {</span>
<span id="cb100-10"><a href="#cb100-10" tabindex="-1"></a>  n <span class="ot">=</span> <span class="fu">length</span>(u)</span>
<span id="cb100-11"><a href="#cb100-11" tabindex="-1"></a>  lambda <span class="ot">=</span> lambda_initial</span>
<span id="cb100-12"><a href="#cb100-12" tabindex="-1"></a>  pre_lambda <span class="ot">=</span> lambda_initial</span>
<span id="cb100-13"><a href="#cb100-13" tabindex="-1"></a>  <span class="co"># 迭代</span></span>
<span id="cb100-14"><a href="#cb100-14" tabindex="-1"></a>  <span class="cf">for</span> (iteration <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>num_iterations) {</span>
<span id="cb100-15"><a href="#cb100-15" tabindex="-1"></a>    E <span class="ot">=</span> <span class="fu">numeric</span>(n)</span>
<span id="cb100-16"><a href="#cb100-16" tabindex="-1"></a>    <span class="cf">for</span> (k <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>n) {</span>
<span id="cb100-17"><a href="#cb100-17" tabindex="-1"></a>      E[k] <span class="ot">=</span> <span class="fu">integrate</span>(integrand, <span class="at">lower =</span> u[k], <span class="at">upper =</span> v[k], </span>
<span id="cb100-18"><a href="#cb100-18" tabindex="-1"></a>                       <span class="at">lambda =</span> lambda, <span class="at">uk =</span> u[k], <span class="at">vk =</span> v[k])<span class="sc">$</span>value</span>
<span id="cb100-19"><a href="#cb100-19" tabindex="-1"></a>    }</span>
<span id="cb100-20"><a href="#cb100-20" tabindex="-1"></a>    lambda <span class="ot">=</span> n<span class="sc">/</span><span class="fu">sum</span>(E)</span>
<span id="cb100-21"><a href="#cb100-21" tabindex="-1"></a>    <span class="co"># whether to stop</span></span>
<span id="cb100-22"><a href="#cb100-22" tabindex="-1"></a>    <span class="cf">if</span> (<span class="fu">abs</span>(lambda <span class="sc">-</span> pre_lambda) <span class="sc">&lt;</span> eps) {</span>
<span id="cb100-23"><a href="#cb100-23" tabindex="-1"></a>      <span class="cf">break</span></span>
<span id="cb100-24"><a href="#cb100-24" tabindex="-1"></a>    }</span>
<span id="cb100-25"><a href="#cb100-25" tabindex="-1"></a>    pre_lambda <span class="ot">=</span> lambda</span>
<span id="cb100-26"><a href="#cb100-26" tabindex="-1"></a>  }</span>
<span id="cb100-27"><a href="#cb100-27" tabindex="-1"></a>  <span class="fu">return</span>(lambda)</span>
<span id="cb100-28"><a href="#cb100-28" tabindex="-1"></a>}</span>
<span id="cb100-29"><a href="#cb100-29" tabindex="-1"></a></span>
<span id="cb100-30"><a href="#cb100-30" tabindex="-1"></a>lambda_initial <span class="ot">=</span> <span class="fl">0.01</span></span>
<span id="cb100-31"><a href="#cb100-31" tabindex="-1"></a>num_iterations <span class="ot">=</span> <span class="fl">1e4</span></span>
<span id="cb100-32"><a href="#cb100-32" tabindex="-1"></a>eps <span class="ot">=</span> <span class="fl">1e-5</span></span>
<span id="cb100-33"><a href="#cb100-33" tabindex="-1"></a>em_lambda <span class="ot">=</span> <span class="fu">em_algorithm</span>(lambda_initial, num_iterations, eps, <span class="at">u =</span> ui, <span class="at">v =</span> vi)</span>
<span id="cb100-34"><a href="#cb100-34" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&quot;Lambda estimated by EM algorithm:&quot;</span>, em_lambda)</span></code></pre></div>
<pre><code>## Lambda estimated by EM algorithm: 0.0719735</code></pre>
<p>通过数值求解的结果可知，MLE与EM算法有着非常相近的求解结果，这一现象支持第一小题的结论，即EM算法收敛于观测数据的MLE。</p>
</div>
<div id="第二题-7" class="section level2">
<h2>第二题</h2>
<p><em>问题描述：</em>在Morra game中，如果从payoff
matrix（收益矩阵）的每一个元素中减去一个常数，或者将收益矩阵的每个元素乘一个正常数，则最优策略集不会改变。然而，单纯形法可能终止于不同的基本可行点（也是最优的）。计算<code>B &lt;- A + 2</code>，找到game
B的解，验证其为原game A的极值点(11.12)-(11.15)之一，并求出game A和game
B的值。</p>
<p><em>思路：</em>在Morra
game中，第一个玩家的目标是要最大化他的收益，相应的最优策略为<span class="math inline">\(x^*\)</span>；第二个玩家的目标是要最小化他的损失，相应的最优策略为<span class="math inline">\(y^*\)</span>。game的期望payoff是<span class="math inline">\(v = x^{*^T}Ay^*\)</span>，用simplex
method进行最优化问题（最大化<span class="math inline">\(v\)</span>、最小化<span class="math inline">\(v\)</span>）的求解。</p>
<p><em>解：</em>我们调用<code>simplex()</code>函数分别求解最大化<span class="math inline">\(v\)</span>、最小化$v的最优化问题，参数<code>maxi</code>分别设置为<code>TRUE</code>和<code>FALSE</code>。将这一步骤封装在自己编写的函数<code>solve.game</code>中。</p>
<div class="sourceCode" id="cb102"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb102-1"><a href="#cb102-1" tabindex="-1"></a><span class="fu">library</span>(boot)</span>
<span id="cb102-2"><a href="#cb102-2" tabindex="-1"></a>solve.game <span class="ot">=</span> <span class="cf">function</span>(payoff.matrix){</span>
<span id="cb102-3"><a href="#cb102-3" tabindex="-1"></a>  <span class="co"># preprocess</span></span>
<span id="cb102-4"><a href="#cb102-4" tabindex="-1"></a>  min.A <span class="ot">=</span> <span class="fu">min</span>(A); A <span class="ot">=</span> A <span class="sc">-</span> min.A; max.A <span class="ot">=</span> <span class="fu">max</span>(A); A <span class="ot">=</span> A <span class="sc">/</span> <span class="fu">max</span>(A)</span>
<span id="cb102-5"><a href="#cb102-5" tabindex="-1"></a>  m <span class="ot">=</span> <span class="fu">nrow</span>(A)</span>
<span id="cb102-6"><a href="#cb102-6" tabindex="-1"></a>  n <span class="ot">=</span> <span class="fu">ncol</span>(A)</span>
<span id="cb102-7"><a href="#cb102-7" tabindex="-1"></a>  iter <span class="ot">=</span> n<span class="sc">^</span><span class="dv">3</span></span>
<span id="cb102-8"><a href="#cb102-8" tabindex="-1"></a>  </span>
<span id="cb102-9"><a href="#cb102-9" tabindex="-1"></a>  <span class="co"># max v</span></span>
<span id="cb102-10"><a href="#cb102-10" tabindex="-1"></a>  <span class="co"># objective function</span></span>
<span id="cb102-11"><a href="#cb102-11" tabindex="-1"></a>  a <span class="ot">=</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">0</span>, m), <span class="dv">1</span>)</span>
<span id="cb102-12"><a href="#cb102-12" tabindex="-1"></a>  <span class="co"># constraint 1 &gt;=，但simplex函数中的A1是&lt;=，所以这里A1前有负号</span></span>
<span id="cb102-13"><a href="#cb102-13" tabindex="-1"></a>  A1 <span class="ot">=</span> <span class="sc">-</span><span class="fu">cbind</span>(<span class="fu">t</span>(A), <span class="fu">rep</span>(<span class="sc">-</span><span class="dv">1</span>, n)) </span>
<span id="cb102-14"><a href="#cb102-14" tabindex="-1"></a>  b1 <span class="ot">=</span> <span class="fu">rep</span>(<span class="dv">0</span>, n)</span>
<span id="cb102-15"><a href="#cb102-15" tabindex="-1"></a>  <span class="co"># constraint 2 sum(x)=1</span></span>
<span id="cb102-16"><a href="#cb102-16" tabindex="-1"></a>  A3 <span class="ot">=</span> <span class="fu">t</span>(<span class="fu">as.matrix</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">1</span>, m), <span class="dv">0</span>)))</span>
<span id="cb102-17"><a href="#cb102-17" tabindex="-1"></a>  b3 <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb102-18"><a href="#cb102-18" tabindex="-1"></a>  sx <span class="ot">=</span> <span class="fu">simplex</span>(<span class="at">a=</span>a, <span class="at">A1=</span>A1, <span class="at">b1=</span>b1, <span class="at">A3=</span>A3, <span class="at">b3=</span>b3, <span class="at">maxi=</span><span class="cn">TRUE</span>, <span class="at">n.iter=</span>iter)</span>
<span id="cb102-19"><a href="#cb102-19" tabindex="-1"></a>  </span>
<span id="cb102-20"><a href="#cb102-20" tabindex="-1"></a>  <span class="co"># min v</span></span>
<span id="cb102-21"><a href="#cb102-21" tabindex="-1"></a>  <span class="co"># objective function</span></span>
<span id="cb102-22"><a href="#cb102-22" tabindex="-1"></a>  a <span class="ot">=</span> <span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">0</span>, n), <span class="dv">1</span>)</span>
<span id="cb102-23"><a href="#cb102-23" tabindex="-1"></a>  <span class="co"># constraint 1 &lt;=</span></span>
<span id="cb102-24"><a href="#cb102-24" tabindex="-1"></a>  A1 <span class="ot">=</span> <span class="fu">cbind</span>(A, <span class="fu">rep</span>(<span class="sc">-</span><span class="dv">1</span>, m))</span>
<span id="cb102-25"><a href="#cb102-25" tabindex="-1"></a>  b1 <span class="ot">=</span> <span class="fu">rep</span>(<span class="dv">0</span>, m)</span>
<span id="cb102-26"><a href="#cb102-26" tabindex="-1"></a>  <span class="co"># constraint 2 sum(y)=1</span></span>
<span id="cb102-27"><a href="#cb102-27" tabindex="-1"></a>  A3 <span class="ot">=</span> <span class="fu">t</span>(<span class="fu">as.matrix</span>(<span class="fu">c</span>(<span class="fu">rep</span>(<span class="dv">1</span>, n), <span class="dv">0</span>)))</span>
<span id="cb102-28"><a href="#cb102-28" tabindex="-1"></a>  b3 <span class="ot">=</span> <span class="dv">1</span></span>
<span id="cb102-29"><a href="#cb102-29" tabindex="-1"></a>  sy <span class="ot">=</span> <span class="fu">simplex</span>(<span class="at">a=</span>a, <span class="at">A1=</span>A1, <span class="at">b1=</span>b1, <span class="at">A3=</span>A3, <span class="at">b3=</span>b3,</span>
<span id="cb102-30"><a href="#cb102-30" tabindex="-1"></a><span class="at">maxi=</span><span class="cn">FALSE</span>, <span class="at">n.iter=</span>iter)</span>
<span id="cb102-31"><a href="#cb102-31" tabindex="-1"></a>  solution.list <span class="ot">=</span> <span class="fu">list</span>(<span class="st">&quot;A&quot;</span> <span class="ot">=</span> A <span class="sc">*</span> max.A <span class="sc">+</span> min.A,</span>
<span id="cb102-32"><a href="#cb102-32" tabindex="-1"></a>                <span class="st">&quot;x&quot;</span> <span class="ot">=</span> sx<span class="sc">$</span>soln[<span class="dv">1</span><span class="sc">:</span>m],</span>
<span id="cb102-33"><a href="#cb102-33" tabindex="-1"></a>                <span class="st">&quot;y&quot;</span> <span class="ot">=</span> sy<span class="sc">$</span>soln[<span class="dv">1</span><span class="sc">:</span>n],</span>
<span id="cb102-34"><a href="#cb102-34" tabindex="-1"></a>                <span class="st">&quot;v&quot;</span> <span class="ot">=</span> sx<span class="sc">$</span>soln[m<span class="sc">+</span><span class="dv">1</span>] <span class="sc">*</span> max.A <span class="sc">+</span> min.A)</span>
<span id="cb102-35"><a href="#cb102-35" tabindex="-1"></a>  solution.list</span>
<span id="cb102-36"><a href="#cb102-36" tabindex="-1"></a>}</span></code></pre></div>
<p>我们给定收益矩阵A的值，并计算矩阵B，调用<code>solve.game</code>函数求出game
B的解。从结果可以看出，与题目所说一致，从payoff
matrix的每一个元素中减去常数2，最优策略集并没有发生改变。在9个策略中，采用第3个策略可以获得最大的收益（或最小的损失）。此外，经过验证，game
B的解为原game A的极值点之一。</p>
<div class="sourceCode" id="cb103"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb103-1"><a href="#cb103-1" tabindex="-1"></a><span class="co"># payoff matrix</span></span>
<span id="cb103-2"><a href="#cb103-2" tabindex="-1"></a>A <span class="ot">&lt;-</span> <span class="fu">matrix</span>(<span class="fu">c</span>( <span class="dv">0</span>,<span class="sc">-</span><span class="dv">2</span>,<span class="sc">-</span><span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">0</span>,</span>
<span id="cb103-3"><a href="#cb103-3" tabindex="-1"></a><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="sc">-</span><span class="dv">3</span>,<span class="sc">-</span><span class="dv">3</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">0</span>,</span>
<span id="cb103-4"><a href="#cb103-4" tabindex="-1"></a><span class="dv">2</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="sc">-</span><span class="dv">4</span>,<span class="sc">-</span><span class="dv">4</span>,</span>
<span id="cb103-5"><a href="#cb103-5" tabindex="-1"></a><span class="sc">-</span><span class="dv">3</span>,<span class="dv">0</span>,<span class="sc">-</span><span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">0</span>,</span>
<span id="cb103-6"><a href="#cb103-6" tabindex="-1"></a><span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="sc">-</span><span class="dv">4</span>,<span class="dv">0</span>,<span class="sc">-</span><span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">0</span>,</span>
<span id="cb103-7"><a href="#cb103-7" tabindex="-1"></a><span class="dv">0</span>,<span class="dv">3</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="sc">-</span><span class="dv">5</span>,<span class="dv">0</span>,<span class="sc">-</span><span class="dv">5</span>,</span>
<span id="cb103-8"><a href="#cb103-8" tabindex="-1"></a><span class="sc">-</span><span class="dv">4</span>,<span class="sc">-</span><span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">5</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">6</span>,</span>
<span id="cb103-9"><a href="#cb103-9" tabindex="-1"></a><span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">4</span>,<span class="sc">-</span><span class="dv">5</span>,<span class="sc">-</span><span class="dv">5</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">6</span>,</span>
<span id="cb103-10"><a href="#cb103-10" tabindex="-1"></a><span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">4</span>,<span class="dv">0</span>,<span class="dv">0</span>,<span class="dv">5</span>,<span class="sc">-</span><span class="dv">6</span>,<span class="sc">-</span><span class="dv">6</span>,<span class="dv">0</span>), <span class="dv">9</span>, <span class="dv">9</span>)</span>
<span id="cb103-11"><a href="#cb103-11" tabindex="-1"></a>B <span class="ot">&lt;-</span> A <span class="sc">+</span> <span class="dv">2</span></span>
<span id="cb103-12"><a href="#cb103-12" tabindex="-1"></a><span class="co"># 计算A的解和B的解</span></span>
<span id="cb103-13"><a href="#cb103-13" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">cbind</span>(<span class="fu">solve.game</span>(A)<span class="sc">$</span>x, <span class="fu">solve.game</span>(A)<span class="sc">$</span>y),<span class="dv">7</span>)</span></code></pre></div>
<pre><code>##         [,1]      [,2]
## x1 0.0000000 0.0000000
## x2 0.0000000 0.0000000
## x3 0.4098361 0.4098361
## x4 0.0000000 0.0000000
## x5 0.3278689 0.3278689
## x6 0.0000000 0.0000000
## x7 0.2622951 0.2622951
## x8 0.0000000 0.0000000
## x9 0.0000000 0.0000000</code></pre>
<div class="sourceCode" id="cb105"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb105-1"><a href="#cb105-1" tabindex="-1"></a><span class="fu">round</span>(<span class="fu">cbind</span>(<span class="fu">solve.game</span>(B)<span class="sc">$</span>x, <span class="fu">solve.game</span>(B)<span class="sc">$</span>y),<span class="dv">7</span>)</span></code></pre></div>
<pre><code>##         [,1]      [,2]
## x1 0.0000000 0.0000000
## x2 0.0000000 0.0000000
## x3 0.4098361 0.4098361
## x4 0.0000000 0.0000000
## x5 0.3278689 0.3278689
## x6 0.0000000 0.0000000
## x7 0.2622951 0.2622951
## x8 0.0000000 0.0000000
## x9 0.0000000 0.0000000</code></pre>
<div class="sourceCode" id="cb107"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb107-1"><a href="#cb107-1" tabindex="-1"></a><span class="co"># 验证game B的解是否为game A的极值点之一</span></span>
<span id="cb107-2"><a href="#cb107-2" tabindex="-1"></a>epointA <span class="ot">=</span> <span class="fu">round</span>(<span class="fu">c</span>(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">25</span><span class="sc">/</span><span class="dv">61</span>, <span class="dv">0</span>, <span class="dv">20</span><span class="sc">/</span><span class="dv">61</span>, <span class="dv">0</span>, <span class="dv">16</span><span class="sc">/</span><span class="dv">61</span>, <span class="dv">0</span>, <span class="dv">0</span>), <span class="dv">7</span>)</span>
<span id="cb107-3"><a href="#cb107-3" tabindex="-1"></a>epointA <span class="sc">==</span> <span class="fu">round</span>(<span class="fu">solve.game</span>(B)<span class="sc">$</span>x, <span class="dv">7</span>)</span></code></pre></div>
<pre><code>##   x1   x2   x3   x4   x5   x6   x7   x8   x9 
## TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE</code></pre>
<div class="sourceCode" id="cb109"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb109-1"><a href="#cb109-1" tabindex="-1"></a>epointA <span class="sc">==</span> <span class="fu">round</span>(<span class="fu">solve.game</span>(B)<span class="sc">$</span>y, <span class="dv">7</span>)</span></code></pre></div>
<pre><code>##   x1   x2   x3   x4   x5   x6   x7   x8   x9 
## TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE</code></pre>
<p>最后，我们求出game A和game B的value，均为0。这是由于Morra Game是zero
sum的Game。</p>
<div class="sourceCode" id="cb111"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb111-1"><a href="#cb111-1" tabindex="-1"></a><span class="fu">solve.game</span>(A)<span class="sc">$</span>v</span></code></pre></div>
<pre><code>## x10 
##   0</code></pre>
<div class="sourceCode" id="cb113"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb113-1"><a href="#cb113-1" tabindex="-1"></a><span class="fu">solve.game</span>(B)<span class="sc">$</span>v </span></code></pre></div>
<pre><code>## x10 
##   0</code></pre>
</div>
</div>
<div id="hw9" class="section level1">
<h1>HW9</h1>
<div id="第一题-8" class="section level2">
<h2>第一题</h2>
<p><em>问题描述：</em>为什么要用<code>unlist()</code>将list转化为atomic
vector？为什么<code>as.vector()</code>不适用？</p>
<p><em>解答：</em>原因如下：</p>
<ul>
<li><p><code>unlist()</code>可以将具有多种数据类型的list转换为一个数据类型一致的向量（按照上课说的就高原则，例如int和chr类型的元素全部转化为chr类型）。</p></li>
<li><p><code>as.vector()</code>主要用于改变向量的类别，它无法将列表转换为扁平化的结构。尤其是在列表为嵌套结构的时候，对数据分析的影响很大。事实上，list是否为嵌套形式，<code>as.vector(list)</code>的结果还是list。</p></li>
</ul>
<p>因此，在将list转换为原子向量时，<code>unlist()</code>函数更适用。</p>
<p>举个例子：</p>
<div class="sourceCode" id="cb115"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb115-1"><a href="#cb115-1" tabindex="-1"></a>list1 <span class="ot">=</span> <span class="fu">list</span>(<span class="st">&#39;a&#39;</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="st">&#39;d&#39;</span>)</span>
<span id="cb115-2"><a href="#cb115-2" tabindex="-1"></a><span class="fu">unlist</span>(list1)</span></code></pre></div>
<pre><code>## [1] &quot;a&quot; &quot;2&quot; &quot;5&quot; &quot;d&quot;</code></pre>
<div class="sourceCode" id="cb117"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb117-1"><a href="#cb117-1" tabindex="-1"></a><span class="fu">as.vector</span>(list1)</span></code></pre></div>
<pre><code>## [[1]]
## [1] &quot;a&quot;
## 
## [[2]]
## [1] 2
## 
## [[3]]
## [1] 5
## 
## [[4]]
## [1] &quot;d&quot;</code></pre>
</div>
<div id="第二题-8" class="section level2">
<h2>第二题</h2>
<p><em>问题描述：</em><code>dim()</code>应用于vector的时候返回什么？</p>
<p><em>解答：</em>返回NULL，这是因为vector是一维的，与矩阵或数组不同，它没有维度信息。正确用法是使用<code>length()</code>。</p>
<p>举个例子：</p>
<div class="sourceCode" id="cb119"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb119-1"><a href="#cb119-1" tabindex="-1"></a>v <span class="ot">=</span> <span class="fu">list</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">7</span>)</span>
<span id="cb119-2"><a href="#cb119-2" tabindex="-1"></a><span class="fu">dim</span>(v)</span></code></pre></div>
<pre><code>## NULL</code></pre>
<div class="sourceCode" id="cb121"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb121-1"><a href="#cb121-1" tabindex="-1"></a><span class="fu">length</span>(v)</span></code></pre></div>
<pre><code>## [1] 4</code></pre>
</div>
<div id="第三题-7" class="section level2">
<h2>第三题</h2>
<p><em>问题描述：</em>如果<code>is.matrix(x)</code>为<code>TRUE</code>，那么<code>is.array(x)</code>返回什么？</p>
<p><em>解答：</em>
<code>is.array(x)</code>也返回<code>TRUE</code>。因为matrix是array的一种特殊形式（矩阵是二维情况下的数组）。</p>
<p>举个例子：</p>
<div class="sourceCode" id="cb123"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb123-1"><a href="#cb123-1" tabindex="-1"></a>m <span class="ot">=</span> <span class="fu">matrix</span>(<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">7</span>), <span class="dv">2</span>, <span class="dv">2</span>)</span>
<span id="cb123-2"><a href="#cb123-2" tabindex="-1"></a><span class="fu">is.matrix</span>(m)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<div class="sourceCode" id="cb125"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb125-1"><a href="#cb125-1" tabindex="-1"></a><span class="fu">is.array</span>(m)</span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="第四题-3" class="section level2">
<h2>第四题</h2>
<p><em>问题描述：</em><code>as.matrix()</code>应用于一个列类型不同的data
frame会发生什么？</p>
<p><em>解答：</em>data
frame会被转换为一个矩阵，并且所有列会被转换为相同的数据类型。转换的原则为：</p>
<p>logical &lt; integer &lt; double &lt; character &lt; list</p>
<p>举个例子：</p>
<div class="sourceCode" id="cb127"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb127-1"><a href="#cb127-1" tabindex="-1"></a>df <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb127-2"><a href="#cb127-2" tabindex="-1"></a>  <span class="at">col1 =</span> <span class="fu">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>, <span class="st">&quot;c&quot;</span>),</span>
<span id="cb127-3"><a href="#cb127-3" tabindex="-1"></a>  <span class="at">col2 =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">8</span>),</span>
<span id="cb127-4"><a href="#cb127-4" tabindex="-1"></a>  <span class="at">col3 =</span> <span class="fu">c</span>(<span class="cn">TRUE</span>, <span class="cn">TRUE</span>, <span class="cn">FALSE</span>),</span>
<span id="cb127-5"><a href="#cb127-5" tabindex="-1"></a>  <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span></span>
<span id="cb127-6"><a href="#cb127-6" tabindex="-1"></a>)</span>
<span id="cb127-7"><a href="#cb127-7" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&#39;type of column 1:&#39;</span>, <span class="fu">typeof</span>(df<span class="sc">$</span>col1), <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>)</span></code></pre></div>
<pre><code>## type of column 1: character</code></pre>
<div class="sourceCode" id="cb129"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb129-1"><a href="#cb129-1" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&#39;type of column 2:&#39;</span>, <span class="fu">typeof</span>(df<span class="sc">$</span>col2), <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>)</span></code></pre></div>
<pre><code>## type of column 2: double</code></pre>
<div class="sourceCode" id="cb131"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb131-1"><a href="#cb131-1" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">&#39;type of column 3:&#39;</span>, <span class="fu">typeof</span>(df<span class="sc">$</span>col3), <span class="st">&#39;</span><span class="sc">\n</span><span class="st">&#39;</span>)</span></code></pre></div>
<pre><code>## type of column 3: logical</code></pre>
<div class="sourceCode" id="cb133"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb133-1"><a href="#cb133-1" tabindex="-1"></a><span class="fu">typeof</span>(<span class="fu">as.matrix</span>(df))</span></code></pre></div>
<pre><code>## [1] &quot;character&quot;</code></pre>
</div>
<div id="第五题-1" class="section level2">
<h2>第五题</h2>
<p><em>问题描述：</em>会有0行的data frame吗？0列呢？</p>
<p><em>解答：</em>有0行0列的data frame，但事实上，列是data
frame的基本组成部分，0列的data frame没有任何意义。</p>
<p>举个例子：</p>
<div class="sourceCode" id="cb135"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb135-1"><a href="#cb135-1" tabindex="-1"></a>df <span class="ot">=</span> <span class="fu">data.frame</span>()</span>
<span id="cb135-2"><a href="#cb135-2" tabindex="-1"></a><span class="fu">ncol</span>(df)</span></code></pre></div>
<pre><code>## [1] 0</code></pre>
<div class="sourceCode" id="cb137"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb137-1"><a href="#cb137-1" tabindex="-1"></a><span class="fu">nrow</span>(df)</span></code></pre></div>
<pre><code>## [1] 0</code></pre>
</div>
<div id="第六题-1" class="section level2">
<h2>第六题</h2>
<p><em>问题描述：</em>下面的函数是对vector进行标准化，使之在[0,
1]之间，你将会怎么把它应用到data frame的每一列？又怎么把它应用到data
frame的每一个数值型列？</p>
<div class="sourceCode" id="cb139"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb139-1"><a href="#cb139-1" tabindex="-1"></a>scale01 <span class="ot">&lt;-</span> <span class="cf">function</span>(x) {</span>
<span id="cb139-2"><a href="#cb139-2" tabindex="-1"></a>  rng <span class="ot">&lt;-</span> <span class="fu">range</span>(x, <span class="at">na.rm =</span> <span class="cn">TRUE</span>)</span>
<span id="cb139-3"><a href="#cb139-3" tabindex="-1"></a>  (x <span class="sc">-</span> rng[<span class="dv">1</span>]) <span class="sc">/</span> (rng[<span class="dv">2</span>] <span class="sc">-</span> rng[<span class="dv">1</span>])</span>
<span id="cb139-4"><a href="#cb139-4" tabindex="-1"></a>}</span></code></pre></div>
<p><em>解答：</em>
注意到<code>scale01()</code>可以处理含有缺失值的数据框，因此我们首先生成一个包含NA的数值型dataframe。用apply族函数中的<code>sapply()</code>，就可以把它应用到data
frame的每一列：</p>
<div class="sourceCode" id="cb140"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb140-1"><a href="#cb140-1" tabindex="-1"></a>df1 <span class="ot">=</span> <span class="fu">data.frame</span>(</span>
<span id="cb140-2"><a href="#cb140-2" tabindex="-1"></a>  <span class="at">col1 =</span> <span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">2</span>, <span class="cn">NA</span>, <span class="dv">4</span>),</span>
<span id="cb140-3"><a href="#cb140-3" tabindex="-1"></a>  <span class="at">col2 =</span> <span class="fu">c</span>(<span class="dv">5</span>, <span class="cn">NA</span>, <span class="dv">7</span>, <span class="dv">8</span>),</span>
<span id="cb140-4"><a href="#cb140-4" tabindex="-1"></a>  <span class="at">col3 =</span> <span class="fu">c</span>(<span class="cn">NA</span>, <span class="dv">10</span>, <span class="dv">11</span>, <span class="dv">12</span>)</span>
<span id="cb140-5"><a href="#cb140-5" tabindex="-1"></a>)</span>
<span id="cb140-6"><a href="#cb140-6" tabindex="-1"></a></span>
<span id="cb140-7"><a href="#cb140-7" tabindex="-1"></a><span class="fu">lapply</span>(df1, scale01)</span></code></pre></div>
<pre><code>## $col1
## [1] 0.0000000 0.3333333        NA 1.0000000
## 
## $col2
## [1] 0.0000000        NA 0.6666667 1.0000000
## 
## $col3
## [1]  NA 0.0 0.5 1.0</code></pre>
<p>接下来，我们生成一个混合型的data
frame。为了对每一个数值型列进行标准化，我们首先要识别出列的类型。从结果可以看出，<code>vapply</code>函数正确识别出了数值型列是第一列和第三列，并计算出了元素的标准化值。</p>
<div class="sourceCode" id="cb142"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb142-1"><a href="#cb142-1" tabindex="-1"></a>df2 <span class="ot">=</span> <span class="fu">data.frame</span>(</span>
<span id="cb142-2"><a href="#cb142-2" tabindex="-1"></a>  <span class="at">col1 =</span> <span class="fu">seq</span>(<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">1</span>),</span>
<span id="cb142-3"><a href="#cb142-3" tabindex="-1"></a>  <span class="at">col2 =</span> <span class="fu">rep</span>(<span class="cn">TRUE</span>, <span class="dv">4</span>),</span>
<span id="cb142-4"><a href="#cb142-4" tabindex="-1"></a>  <span class="at">col3 =</span> <span class="fu">seq</span>(<span class="dv">9</span>,<span class="dv">15</span>,<span class="dv">2</span>),</span>
<span id="cb142-5"><a href="#cb142-5" tabindex="-1"></a>  <span class="at">col4 =</span> <span class="fu">rep</span>(<span class="st">&#39;a&#39;</span>, <span class="dv">4</span>),</span>
<span id="cb142-6"><a href="#cb142-6" tabindex="-1"></a>  <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span></span>
<span id="cb142-7"><a href="#cb142-7" tabindex="-1"></a>)</span>
<span id="cb142-8"><a href="#cb142-8" tabindex="-1"></a>numeric.idx <span class="ot">=</span> <span class="fu">vapply</span>(df2, is.numeric, <span class="at">FUN.VALUE=</span><span class="fu">logical</span>(<span class="dv">1</span>))</span>
<span id="cb142-9"><a href="#cb142-9" tabindex="-1"></a><span class="fu">lapply</span>(df2[, numeric.idx], scale01)</span></code></pre></div>
<pre><code>## $col1
## [1] 0.0000000 0.3333333 0.6666667 1.0000000
## 
## $col3
## [1] 0.0000000 0.3333333 0.6666667 1.0000000</code></pre>
</div>
<div id="第七题" class="section level2">
<h2>第七题</h2>
<p><em>问题描述：</em>用<code>vapply()</code>完成以下操作：</p>
<ol style="list-style-type: lower-alpha">
<li><p>计算一个数值型data frame的每一列的标准差standard
deviation.</p></li>
<li><p>计算一个混合型data frame的每一个数值型列的标准差standard
deviation.(Hint: use <code>vapply()</code> twice.)</p></li>
</ol>
<p><em>解答：</em> a) 构建一个数值型data
frame，并用<code>vapply()</code>计算每一列的标准差standard
deviation，注意需要指定默认值<code>FUN.VALUE</code>。</p>
<div class="sourceCode" id="cb144"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb144-1"><a href="#cb144-1" tabindex="-1"></a>df1 <span class="ot">=</span> <span class="fu">data.frame</span>(</span>
<span id="cb144-2"><a href="#cb144-2" tabindex="-1"></a>  <span class="at">col1 =</span> <span class="fu">seq</span>(<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">1</span>),</span>
<span id="cb144-3"><a href="#cb144-3" tabindex="-1"></a>  <span class="at">col2 =</span> <span class="fu">seq</span>(<span class="dv">5</span>,<span class="dv">8</span>,<span class="dv">1</span>),</span>
<span id="cb144-4"><a href="#cb144-4" tabindex="-1"></a>  <span class="at">col3 =</span> <span class="fu">seq</span>(<span class="dv">9</span>,<span class="dv">15</span>,<span class="dv">2</span>)</span>
<span id="cb144-5"><a href="#cb144-5" tabindex="-1"></a>)</span>
<span id="cb144-6"><a href="#cb144-6" tabindex="-1"></a><span class="fu">vapply</span>(df1, sd, <span class="at">FUN.VALUE=</span><span class="dv">0</span>)</span></code></pre></div>
<pre><code>##     col1     col2     col3 
## 1.290994 1.290994 2.581989</code></pre>
<ol start="2" style="list-style-type: lower-alpha">
<li>构建一个混合型data
frame，先用<code>vapply()</code>识别每一列的类型，如果是数值型列，则记录列的下标，然后再用一次<code>vapply()</code>计算数值型列的标准差standard
deviation，同样地，需要指定默认值<code>FUN.VALUE</code>。</li>
</ol>
<div class="sourceCode" id="cb146"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb146-1"><a href="#cb146-1" tabindex="-1"></a>df2 <span class="ot">=</span> <span class="fu">data.frame</span>(</span>
<span id="cb146-2"><a href="#cb146-2" tabindex="-1"></a>  <span class="at">col1 =</span> <span class="fu">seq</span>(<span class="dv">1</span>,<span class="dv">4</span>,<span class="dv">1</span>),</span>
<span id="cb146-3"><a href="#cb146-3" tabindex="-1"></a>  <span class="at">col2 =</span> <span class="fu">rep</span>(<span class="cn">TRUE</span>, <span class="dv">4</span>),</span>
<span id="cb146-4"><a href="#cb146-4" tabindex="-1"></a>  <span class="at">col3 =</span> <span class="fu">seq</span>(<span class="dv">9</span>,<span class="dv">15</span>,<span class="dv">2</span>),</span>
<span id="cb146-5"><a href="#cb146-5" tabindex="-1"></a>  <span class="at">col4 =</span> <span class="fu">rep</span>(<span class="st">&#39;a&#39;</span>, <span class="dv">4</span>),</span>
<span id="cb146-6"><a href="#cb146-6" tabindex="-1"></a>  <span class="at">stringsAsFactors =</span> <span class="cn">FALSE</span></span>
<span id="cb146-7"><a href="#cb146-7" tabindex="-1"></a>)</span>
<span id="cb146-8"><a href="#cb146-8" tabindex="-1"></a>numeric.idx <span class="ot">=</span> <span class="fu">vapply</span>(df2, is.numeric, <span class="at">FUN.VALUE=</span><span class="fu">logical</span>(<span class="dv">1</span>))</span>
<span id="cb146-9"><a href="#cb146-9" tabindex="-1"></a><span class="fu">vapply</span>(df2[, numeric.idx], sd, <span class="at">FUN.VALUE=</span><span class="dv">0</span>)</span></code></pre></div>
<pre><code>##     col1     col3 
## 1.290994 2.581989</code></pre>
</div>
<div id="第八题" class="section level2">
<h2>第八题</h2>
<p><em>问题描述：</em>考虑一个二元密度函数： <span class="math display">\[f(x,y) \propto
C_n^xy^{x+a+1}(1-y)^{n-x+b-1},~x=0,1,...,n,~0\leq y\leq 1.\]</span>
对于固定的<span class="math inline">\(a,b,n\)</span>，边际分布分别为<span class="math inline">\(B(n,y)\)</span>和<span class="math inline">\(Beta(x+a,n-x+b)\)</span>。用Gibbs
sampler生成一条具有目标联合密度的链。</p>
<ul>
<li><p>写一个R函数；</p></li>
<li><p>写一个Rcpp函数；</p></li>
<li><p>用函数<code>microbenchmark</code>来比较两个函数的运行时间。</p></li>
</ul>
<p><em>解答：</em>Gibbs算法的流程如下所示，在每一轮迭代中：</p>
<p>1）设<span class="math inline">\((x,y)=(X_{t-1},Y_{t-1})\)</span>，</p>
<p>2）从<span class="math inline">\(f(X|y)\)</span>生成样本<span class="math inline">\(X^*_t\)</span>，</p>
<p>3）令<span class="math inline">\(x_t = X^*_t\)</span>，</p>
<p>4）从<span class="math inline">\(f(Y|x)\)</span>生成样本<span class="math inline">\(Y^*_t\)</span>，</p>
<p>5）设<span class="math inline">\((X_{t},Y_{t})=(X^*_t,Y^*_t)\)</span>。</p>
<p>根据题设条件，<span class="math inline">\(f(X|y)\)</span>和<span class="math inline">\(f(Y|x)\)</span>分别为<span class="math inline">\(B(n,y)\)</span>和<span class="math inline">\(Beta(x+a,n-x+b)\)</span>。将上述流程分别写成R函数和Rcpp函数。</p>
<div class="sourceCode" id="cb148"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb148-1"><a href="#cb148-1" tabindex="-1"></a>gibbsR <span class="ot">=</span> <span class="cf">function</span>(N, burn, a, b, n, seed){</span>
<span id="cb148-2"><a href="#cb148-2" tabindex="-1"></a>  <span class="co"># N: length of chain</span></span>
<span id="cb148-3"><a href="#cb148-3" tabindex="-1"></a>  <span class="co"># burn: burn-in length</span></span>
<span id="cb148-4"><a href="#cb148-4" tabindex="-1"></a>  <span class="co"># a, b, n: parameter of density</span></span>
<span id="cb148-5"><a href="#cb148-5" tabindex="-1"></a>  <span class="co"># seed: random seed</span></span>
<span id="cb148-6"><a href="#cb148-6" tabindex="-1"></a>  <span class="fu">set.seed</span>(seed)</span>
<span id="cb148-7"><a href="#cb148-7" tabindex="-1"></a>  data <span class="ot">=</span> <span class="fu">matrix</span>(<span class="dv">0</span>, N, <span class="dv">2</span>)</span>
<span id="cb148-8"><a href="#cb148-8" tabindex="-1"></a>  data[<span class="dv">1</span>, ] <span class="ot">=</span> <span class="fu">c</span>(n<span class="dv">-1</span>, <span class="dv">1</span><span class="sc">/</span><span class="dv">2</span>)</span>
<span id="cb148-9"><a href="#cb148-9" tabindex="-1"></a>  <span class="cf">for</span> (i <span class="cf">in</span> <span class="dv">2</span><span class="sc">:</span>N) {</span>
<span id="cb148-10"><a href="#cb148-10" tabindex="-1"></a>    y <span class="ot">=</span> data[i<span class="dv">-1</span>, <span class="dv">2</span>]</span>
<span id="cb148-11"><a href="#cb148-11" tabindex="-1"></a>    data[i, <span class="dv">1</span>] <span class="ot">=</span> <span class="fu">rbinom</span>(<span class="dv">1</span>, n, y)</span>
<span id="cb148-12"><a href="#cb148-12" tabindex="-1"></a>    x <span class="ot">=</span> data[i, <span class="dv">1</span>]</span>
<span id="cb148-13"><a href="#cb148-13" tabindex="-1"></a>    data[i, <span class="dv">2</span>] <span class="ot">=</span> <span class="fu">rbeta</span>(<span class="dv">1</span>, x<span class="sc">+</span>a, n<span class="sc">-</span>x<span class="sc">+</span>b)</span>
<span id="cb148-14"><a href="#cb148-14" tabindex="-1"></a>  }</span>
<span id="cb148-15"><a href="#cb148-15" tabindex="-1"></a>  chain <span class="ot">=</span> data[(burn<span class="sc">+</span><span class="dv">1</span>)<span class="sc">:</span>N,]</span>
<span id="cb148-16"><a href="#cb148-16" tabindex="-1"></a>  <span class="fu">return</span>(chain)</span>
<span id="cb148-17"><a href="#cb148-17" tabindex="-1"></a>}</span></code></pre></div>
<div class="sourceCode" id="cb149"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span id="cb149-1"><a href="#cb149-1" tabindex="-1"></a><span class="pp">#include </span><span class="im">&lt;Rcpp.h&gt;</span></span>
<span id="cb149-2"><a href="#cb149-2" tabindex="-1"></a><span class="kw">using</span> <span class="kw">namespace</span> Rcpp<span class="op">;</span></span>
<span id="cb149-3"><a href="#cb149-3" tabindex="-1"></a></span>
<span id="cb149-4"><a href="#cb149-4" tabindex="-1"></a><span class="co">// [[Rcpp::export]]</span></span>
<span id="cb149-5"><a href="#cb149-5" tabindex="-1"></a>NumericMatrix gibbsCpp<span class="op">(</span><span class="dt">int</span> N<span class="op">,</span> <span class="dt">int</span> burn<span class="op">,</span> <span class="dt">double</span> a<span class="op">,</span> <span class="dt">double</span> b<span class="op">,</span> <span class="dt">int</span> n<span class="op">)</span> <span class="op">{</span></span>
<span id="cb149-6"><a href="#cb149-6" tabindex="-1"></a>  <span class="co">// N: length of chain</span></span>
<span id="cb149-7"><a href="#cb149-7" tabindex="-1"></a>  <span class="co">// burn: burn-in length</span></span>
<span id="cb149-8"><a href="#cb149-8" tabindex="-1"></a>  <span class="co">// a, b, n: parameter of density</span></span>
<span id="cb149-9"><a href="#cb149-9" tabindex="-1"></a>  <span class="co">// seed: random seed</span></span>
<span id="cb149-10"><a href="#cb149-10" tabindex="-1"></a>  RNGScope scope<span class="op">;</span>  <span class="co">// Initialize random number generator</span></span>
<span id="cb149-11"><a href="#cb149-11" tabindex="-1"></a>  </span>
<span id="cb149-12"><a href="#cb149-12" tabindex="-1"></a>  NumericMatrix data<span class="op">(</span>N<span class="op">,</span> <span class="dv">2</span><span class="op">);</span></span>
<span id="cb149-13"><a href="#cb149-13" tabindex="-1"></a>  data<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">=</span> n <span class="op">-</span> <span class="dv">1</span><span class="op">;</span></span>
<span id="cb149-14"><a href="#cb149-14" tabindex="-1"></a>  data<span class="op">(</span><span class="dv">0</span><span class="op">,</span> <span class="dv">1</span><span class="op">)</span> <span class="op">=</span> <span class="fl">0.5</span><span class="op">;</span></span>
<span id="cb149-15"><a href="#cb149-15" tabindex="-1"></a>  </span>
<span id="cb149-16"><a href="#cb149-16" tabindex="-1"></a>  <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> N<span class="op">;</span> i<span class="op">++)</span> <span class="op">{</span></span>
<span id="cb149-17"><a href="#cb149-17" tabindex="-1"></a>    <span class="dt">double</span> y <span class="op">=</span> data<span class="op">(</span>i <span class="op">-</span> <span class="dv">1</span><span class="op">,</span> <span class="dv">1</span><span class="op">);</span></span>
<span id="cb149-18"><a href="#cb149-18" tabindex="-1"></a>    data<span class="op">(</span>i<span class="op">,</span> <span class="dv">0</span><span class="op">)</span> <span class="op">=</span> R<span class="op">::</span>rbinom<span class="op">(</span>n<span class="op">,</span> y<span class="op">);</span></span>
<span id="cb149-19"><a href="#cb149-19" tabindex="-1"></a>    <span class="dt">double</span> x <span class="op">=</span> data<span class="op">(</span>i<span class="op">,</span> <span class="dv">0</span><span class="op">);</span></span>
<span id="cb149-20"><a href="#cb149-20" tabindex="-1"></a>    data<span class="op">(</span>i<span class="op">,</span> <span class="dv">1</span><span class="op">)</span> <span class="op">=</span> R<span class="op">::</span>rbeta<span class="op">(</span>x<span class="op">+</span>a<span class="op">,</span> n<span class="op">-</span>x<span class="op">+</span>b<span class="op">);</span></span>
<span id="cb149-21"><a href="#cb149-21" tabindex="-1"></a>  <span class="op">}</span></span>
<span id="cb149-22"><a href="#cb149-22" tabindex="-1"></a>  </span>
<span id="cb149-23"><a href="#cb149-23" tabindex="-1"></a>  NumericMatrix chain <span class="op">=</span> data<span class="op">(</span>Range<span class="op">(</span>burn<span class="op">,</span> N <span class="op">-</span> <span class="dv">1</span><span class="op">),</span> _<span class="op">);</span></span>
<span id="cb149-24"><a href="#cb149-24" tabindex="-1"></a>  <span class="cf">return</span> chain<span class="op">;</span></span>
<span id="cb149-25"><a href="#cb149-25" tabindex="-1"></a><span class="op">}</span></span></code></pre></div>
<p>在Rcpp函数中，需要注意的是，不需要指定随机种子。接下来，我们以样本量5000，预烧样本量1000，a=2,
b=3,
n=9作为指定的参数输入函数。根据<code>x</code>和<code>y</code>的取值范围，MCMC链的初始值设定为<code>(n-1, 0.5)</code>。</p>
<div class="sourceCode" id="cb150"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb150-1"><a href="#cb150-1" tabindex="-1"></a><span class="fu">library</span>(microbenchmark)</span>
<span id="cb150-2"><a href="#cb150-2" tabindex="-1"></a><span class="fu">library</span>(Rcpp)</span></code></pre></div>
<pre><code>## Warning: package &#39;Rcpp&#39; was built under R version 4.3.2</code></pre>
<div class="sourceCode" id="cb152"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb152-1"><a href="#cb152-1" tabindex="-1"></a>time <span class="ot">=</span> <span class="fu">microbenchmark</span>(<span class="at">timeR=</span><span class="fu">gibbsR</span>(<span class="dv">5000</span>, <span class="dv">1000</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">9</span>, <span class="dv">12345</span>), </span>
<span id="cb152-2"><a href="#cb152-2" tabindex="-1"></a>                      <span class="at">timeCpp =</span> <span class="fu">gibbsCpp</span>(<span class="dv">5000</span>, <span class="dv">1000</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">9</span>))</span>
<span id="cb152-3"><a href="#cb152-3" tabindex="-1"></a><span class="fu">summary</span>(time)[,<span class="fu">c</span>(<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">5</span>,<span class="dv">6</span>)]</span></code></pre></div>
<pre><code>##      expr       lq   median      uq
## 1   timeR 14.54410 15.96290 22.0353
## 2 timeCpp  1.26065  1.27265  1.2878</code></pre>
<p>输出的结果表格展示了两个函数执行时间的分布。第一行是R函数运行时间的25%分位数、中位数、75%分位数；第二行是Rcpp函数运行时间的25%分位数、中位数、75%分位数。可以看出Rcpp函数运行时间比R函数要短得多。</p>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
